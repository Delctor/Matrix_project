#pragma once

#include <iostream>
#include <cmath>
#include <algorithm>
#include <immintrin.h>

#define uint32_to_float(v) __m256i v2 = _mm256_srli_epi32(v, 1); \
    __m256i v1 = _mm256_sub_epi32(v, v2); \
    __m256 v2f = _mm256_cvtepi32_ps(v2); \
    __m256 v1f = _mm256_cvtepi32_ps(v1); \
    __m256 uint32ToFloat = _mm256_add_ps(v2f, v1f);

#define uint64_to_double(v) __m256d uint64ToDouble = _mm256_add_pd(_mm256_sub_pd(_mm256_castsi256_pd(_mm256_or_si256(_mm256_srli_epi64(v, 32), mask1)), _mm256_castsi256_pd(mask3)), _mm256_castsi256_pd(_mm256_blend_epi16(v, mask2, 204)));

#define masks_uint64_to_double __m256i mask1 = _mm256_castpd_si256(_mm256_set1_pd(19342813113834066795298816.0)); \
	__m256i mask2 = _mm256_castpd_si256(_mm256_set1_pd(4503599627370496.0)); \
	__m256i mask3 = _mm256_castpd_si256(_mm256_set1_pd(19342813118337666422669312.0));



#define True 0b11111111
#define False 0b00000000

#ifdef __cplusplus
#define INITIALIZER(f) \
        static void f(void); \
        struct f##_t_ { f##_t_(void) { f(); } }; static f##_t_ f##_; \
        static void f(void)
#elif defined(_MSC_VER)
#pragma section(".CRT$XCU",read)
#define INITIALIZER2_(f,p) \
        static void f(void); \
        __declspec(allocate(".CRT$XCU")) void (*f##_)(void) = f; \
        __pragma(comment(linker,"/include:" p #f "_")) \
        static void f(void)
#ifdef _WIN64
#define INITIALIZER(f) INITIALIZER2_(f,"")
#else
#define INITIALIZER(f) INITIALIZER2_(f,"_")
#endif
#else
#define INITIALIZER(f) \
        static void f(void) __attribute__((constructor)); \
        static void f(void)
#endif

namespace alge
{
	template <typename T>
	class vector 
	{
		static_assert(std::is_same<T, double>::value || 
			std::is_same<T, float>::value ||
			std::is_same<T, int>::value || 
			std::is_same<T, uint64_t>::value || 
			std::is_same<T, int64_t>::value ||
			std::is_same<T, uint8_t>::value
			,
			"The data type can only be double, float, int, uint64_t or int64_t or uint8_t");
	};
	
	template <typename T, bool tranposed = false, bool contiguous = true>
	class matrix
	{
		static_assert(std::is_same<T, double>::value ||
			std::is_same<T, float>::value ||
			std::is_same<T, uint8_t>::value
			,
			"The data type can only be double, float or uint8_t");
	};

	//-----------------------------------

	__m256i __seeds__;

	INITIALIZER(initialize)
	{
		uint64_t seeds[4];
		_rdrand64_step(seeds);
		_rdrand64_step(seeds + 1);
		_rdrand64_step(seeds + 2);
		_rdrand64_step(seeds + 3);
		__seeds__ = _mm256_loadu_epi64(seeds);
	}

	// Vector

	template <>
	class vector<uint8_t>
	{
	public:
		/*I am using uint8_t to emulate bool that is why this class has no arithmetic operation methods*/

		inline vector() : _data(nullptr), dataToDelete(nullptr), _size(0), finalPos(0), finalPos256(0) {}

		inline vector(size_t size) : _data(new uint8_t[size]), dataToDelete(_data), _size(size), finalPos((size / 32) * 32), finalPos256((size / 256) * 256) {}

		inline vector(uint8_t* data, size_t size) : _data(data), dataToDelete(nullptr), _size(size), finalPos((size / 32) * 32), finalPos256((size / 256) * 256) {}

		inline ~vector() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		// These functions are like numpy.where

		friend inline vector<double> where(vector<uint8_t>&, vector<double>&, vector<double>&);

		friend inline vector<float> where(vector<uint8_t>&, vector<float>&, vector<float>&);

		friend inline vector<uint64_t> where(vector<uint8_t>&, vector<uint64_t>&, vector<uint64_t>&);

		friend inline vector<int> where(vector<uint8_t>&, vector<int>&, vector<int>&);

		// Double

		friend inline vector<double> where(vector<uint8_t>&, double, double);

		friend inline vector<double> where(vector<uint8_t>&, vector<double>&, double);

		friend inline vector<double> where(vector<uint8_t>&, double, vector<double>&);

		// Float

		friend inline vector<float> where(vector<uint8_t>&, float, float);

		friend inline vector<float> where(vector<uint8_t>&, vector<float>&, float);

		friend inline vector<float> where(vector<uint8_t>&, float, vector<float>&);

		// Int

		friend inline vector<int> where(vector<uint8_t>&, int, int);

		friend inline vector<int> where(vector<uint8_t>&, vector<int>&, int);

		friend inline vector<int> where(vector<uint8_t>&, int, vector<int>&);

		// uint64_t

		friend inline vector<uint64_t> where(vector<uint8_t>&, uint64_t, uint64_t);

		friend inline vector<uint64_t> where(vector<uint8_t>&, vector<uint64_t>&, uint64_t);

		friend inline vector<uint64_t> where(vector<uint8_t>&, uint64_t, vector<uint64_t>&);

		friend inline vector<uint64_t> where(vector<uint8_t>&);

		friend std::ostream& operator<<(std::ostream& os, const vector<uint8_t>& vector);

		template<typename T>
		friend inline vector<T> concatenate(vector<T>& vector1, vector<T>& vector2);

		inline uint8_t* data() { return this->_data; }

		inline size_t size() { return this->_size; }

		inline uint8_t& operator[](size_t index)
		{
			uint8_t* data = this->_data;
			return data[index];
		}

		inline const uint8_t& operator[](size_t index) const
		{
			uint8_t* data = this->_data;
			return data[index];
		}

		inline vector<uint8_t> operator[](vector<uint64_t>&);

		inline vector<uint8_t> block(size_t initial, size_t final)
		{
			return vector<uint8_t>(
				&this->_data[initial],
				final - initial
			);
		}

		// Copy

		inline vector<uint8_t> copy()
		{
			size_t size = this->_size;

			vector<uint8_t> result(size);

			uint8_t* data1 = this->_data;

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[i];
			}
			return result;
		}

		// Set Constant

		inline void set_const(uint8_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;

			for (size_t i = 0; i < size; i++)
			{
				data1[i] = num;
			}
		}

		// =

		inline vector<uint8_t>& operator=(vector<uint8_t>& other)
		{
			if (this->_data == nullptr)
			{
				this->_data = other._data;
				other.dataToDelete = nullptr;
				this->dataToDelete = this->_data;
				this->_size = other._size;
				this->finalPos = other.finalPos;
			}
			else
			{
#ifdef _DEBUG
				if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
				size_t size = this->_size;
				uint8_t* data1 = this->_data;
				uint8_t* data2 = other._data;

				for (size_t i = 0; i < size; i++)
				{
					data1[i] = data2[i];
				}
			}
			return *this;
		}

		// Transfer

		inline void transfer(vector<uint8_t>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_size = other._size;
			this->finalPos = other.finalPos;
			this->finalPos256 = other.finalPos256;
		}


		// &&

		inline vector<uint8_t> operator&&(vector<uint8_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;
			uint8_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);
				__m256i b = _mm256_loadu_epi8(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_and_si256(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] & data2[i];
			}
			return result;
		}

		inline vector<uint8_t> operator&&(uint8_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi8(num);

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);

				_mm256_storeu_epi8(&dataResult[i], _mm256_and_si256(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] & num;
			}
			return result;
		}

		// ||

		inline vector<uint8_t> operator||(vector<uint8_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;
			uint8_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);
				__m256i b = _mm256_loadu_epi8(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_or_si256(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] | data2[i];
			}
			return result;
		}

		inline vector<uint8_t> operator||(uint8_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi8(num);

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);

				_mm256_storeu_epi8(&dataResult[i], _mm256_or_si256(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] | num;
			}
			return result;
		}

		// !

		inline vector<uint8_t> operator!()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);

				_mm256_storeu_epi8(&dataResult[i], _mm256_and_si256(a, zero));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] & 0;
			}
			return result;
		}

		inline void self_not()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint8_t* data1 = this->_data;

			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 32)
			{
				__m256i a = _mm256_loadu_epi8(&data1[i]);

				_mm256_storeu_epi8(&data1[i], _mm256_and_si256(a, zero));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] & 0;
			}
		}

		// Count

		inline uint64_t count()
		{
			size_t size = this->_size;

			size_t finalPos256 = this->finalPos256;

			uint8_t* data1 = this->_data;

			uint64_t sum = 0;

			for (size_t i = 0; i < finalPos256; i += 256)
			{
				/*
				I am using _mm256_movemask_epi8 to get the 32 bit most significant bit that 
				I previously loaded with _mm256_loadu_epi8 and using _mm_popcnt_u32 to 
				get the number of bits that are one
				*/
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 32])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 64])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 96])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 128])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 160])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 192])));
				sum += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 224])));
			}
			for (size_t i = finalPos256; i < size; i++)
			{
				if (data1[i]) sum++;
			}
			return sum;
		}

		// Cast

		template<typename T>
		inline vector<T> cast()
		{
			size_t size = this->_size;

			uint8_t* data1 = this->_data;

			vector<T> result(size);

			T* dataResult = result._data;

			if constexpr (std::is_same<T, double>::value)
			{
				size_t finalPos = (this->_size / 4) * 4;
				__m256d zero = _mm256_setzero_pd();
				__m256d one = _mm256_set1_pd(1.0);

				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(zero, one, _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_loadu_epi8(&data1[i])))));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? 1.0 : 0.0;
				}
			}
			else if constexpr (std::is_same<T, float>::value)
			{
				size_t finalPos = (this->_size / 8) * 8;
				__m256 zero = _mm256_setzero_ps();
				__m256 one = _mm256_set1_ps(1.0f);

				for (size_t i = 0; i < finalPos; i += 8)
				{
					_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(zero, one, _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_loadu_epi8(&data1[i])))));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? 1.0f : 0.0f;
				}
			}
			else if constexpr (std::is_same<T, uint64_t>::value)
			{
				size_t finalPos = (this->_size / 4) * 4;
				__m256i zero = _mm256_setzero_si256();
				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm256_storeu_epi64(&dataResult[i], _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(zero), _mm256_castsi256_pd(one), _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_loadu_epi8(&data1[i]))))));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? 1 : 0;
				}
			}
			else if constexpr (std::is_same<T, int>::value)
			{
				size_t finalPos = (this->_size / 8) * 8;
				__m256i zero = _mm256_setzero_si256();
				__m256i one = _mm256_set1_epi32(1);

				for (size_t i = 0; i < finalPos; i += 8)
				{
					_mm256_storeu_epi32(&dataResult[i], _mm256_castps_si256(_mm256_blendv_ps(_mm256_castsi256_ps(zero), _mm256_castsi256_ps(one), _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_loadu_epi8(&data1[i]))))));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? 1 : 0;
				}
			}
			return result;
		}

	private:
		uint8_t* _data;
		uint8_t* dataToDelete;
		size_t _size;
		size_t finalPos, finalPos256;
	};

	template <>
	class vector<uint64_t>
	{
	public:
		inline vector() : _data(nullptr), dataToDelete(nullptr), _size(0), finalPos(0) {}

		inline vector(size_t size) : _data(new uint64_t[size]), dataToDelete(_data), _size(size), finalPos((size / 4) * 4) {}

		inline vector(uint64_t* data, size_t size) : _data(data), dataToDelete(nullptr), _size(size), finalPos((size / 4) * 4) {}

		inline ~vector() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		friend inline vector<uint64_t> where(vector<uint8_t>&, vector<uint64_t>&, vector<uint64_t>&);

		friend inline vector<uint64_t> where(vector<uint8_t>&, uint64_t, uint64_t);

		friend inline vector<uint64_t> where(vector<uint8_t>&, vector<uint64_t>&, uint64_t);

		friend inline vector<uint64_t> where(vector<uint8_t>&, uint64_t, vector<uint64_t>&);

		friend inline vector<uint64_t> where(vector<uint8_t>&);

		friend std::ostream& operator<<(std::ostream& os, const vector<uint64_t>& vector);

		friend inline vector<uint64_t> operator+(uint64_t, vector<uint64_t>&);

		friend inline vector<uint64_t> operator-(uint64_t, vector<uint64_t>&);

		friend inline vector<uint64_t> operator/(uint64_t, vector<uint64_t>&);

		friend inline vector<uint64_t> operator*(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator==(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator!=(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator>(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator>=(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator<(uint64_t, vector<uint64_t>&);

		friend inline vector<uint8_t> operator<=(uint64_t, vector<uint64_t>&);

		template<typename T>
		friend inline vector<T> concatenate(vector<T>& vector1, vector<T>& vector2);

		inline uint64_t* data() { return this->_data; }

		inline size_t size() { return this->_size; }

		inline uint64_t& operator[](size_t index)
		{
			uint64_t* data = this->_data;
			return data[index];
		}

		inline const uint64_t& operator[](size_t index) const
		{
			uint64_t* data = this->_data;
			return data[index];
		}

		// Block

		inline vector<uint64_t> block(size_t initial, size_t final)
		{
			return vector<uint64_t>(
				&this->_data[initial],
				final - initial
			);
		}

		// Copy

		inline vector<uint64_t> copy()
		{
			size_t size = this->_size;

			vector<uint64_t> result(size);

			uint64_t* data1 = this->_data;

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[i];
			}
			return result;
		}

		// = 

		inline vector<uint64_t>& operator=(vector<uint64_t>& other)
		{
			if (this->_data == nullptr)
			{
				this->_data = other._data;
				other.dataToDelete = nullptr;
				this->dataToDelete = this->_data;
				this->_size = other._size;
				this->finalPos = other.finalPos;
			}
			else
			{
#ifdef _DEBUG
				if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
				size_t size = this->_size;
				uint64_t* data1 = this->_data;
				uint64_t* data2 = other._data;

				for (size_t i = 0; i < size; i++)
				{
					data1[i] = data2[i];
				}
			}
			return *this;
		}

		// Transfer

		inline void transfer(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_size = other._size;
			this->finalPos = other.finalPos;
		}

		// Set Constant

		inline void set_const(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			for (size_t i = 0; i < size; i++)
			{
				data1[i] = num;
			}
		}

		// +

		inline vector<uint64_t> operator+(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_add_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + data2[i];
			}
			return result;
		}

		inline vector<uint64_t> operator+(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_add_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + num;
			}
			return result;
		}

		inline void operator+=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_add_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] += data2[i];
			}
		}

		inline void operator+=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_add_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] += num;
			}
		}

		// -

		inline vector<uint64_t> operator-(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_sub_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - data2[i];
			}
			return result;
		}

		inline vector<uint64_t> operator-(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_sub_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - num;
			}
			return result;
		}

		inline void operator-=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_sub_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] -= data2[i];
			}
		}

		inline void operator-=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_sub_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] -= num;
			}
		}

		// *

		inline vector<uint64_t> operator*(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_mul_epu32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * data2[i];
			}
			return result;
		}

		inline vector<uint64_t> operator*(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_mul_epu32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * num;
			}
			return result;
		}

		inline void operator*=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_mul_epu32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] *= data2[i];
			}
		}

		inline void operator*=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_mul_epu32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] *= num;
			}
		}

		// /

		inline vector<uint64_t> operator/(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_div_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / data2[i];
			}
			return result;
		}

		inline vector<uint64_t> operator/(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&dataResult[i], _mm256_div_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / num;
			}
			return result;
		}

		inline void operator/=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_div_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] /= data2[i];
			}
		}

		inline void operator/=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				_mm256_storeu_epi64(&data1[i], _mm256_div_epi64(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] /= num;
			}
		}

		// ==

		inline vector<uint8_t> operator==(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i mask = _mm256_cmpeq_epi64(a, b);

				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator==(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i mask = _mm256_cmpeq_epi64(a, b);

				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == num ? True : False;
			}
			return result;
		}

		// !=

		inline vector<uint8_t> operator!=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpeq_epi64(a, b), minus_ones);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator!=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i mask = _mm256_andnot_si256((_mm256_cmpeq_epi64(a, b)), minus_ones);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != num ? True : False;
			}
			return result;
		}

		// >

		inline vector<uint8_t> operator>(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i mask = _mm256_cmpgt_epi64(a, b);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = (size / 4) * 4;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i mask = _mm256_cmpgt_epi64(a, b);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > num ? True : False;
			}
			return result;
		}

		// < 

		inline vector<uint8_t> operator<(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i gt = _mm256_cmpgt_epi64(a, b);
				__m256i eq = _mm256_cmpeq_epi64(a, b);

				__m256i mask = _mm256_andnot_si256(gt, _mm256_andnot_si256(eq, minus_ones));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i gt = _mm256_cmpgt_epi64(a, b);
				__m256i eq = _mm256_cmpeq_epi64(a, b);

				__m256i mask = _mm256_andnot_si256(gt, _mm256_andnot_si256(eq, minus_ones));

				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < num ? True : False;
			}
			return result;
		}

		// >=

		inline vector<uint8_t> operator>=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i gt = _mm256_cmpgt_epi64(a, b);
				__m256i eq = _mm256_cmpeq_epi64(a, b);

				__m256i mask = _mm256_or_si256(gt, eq);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i gt = _mm256_cmpgt_epi64(a, b);
				__m256i eq = _mm256_cmpeq_epi64(a, b);

				__m256i mask = _mm256_or_si256(gt, eq);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= num ? True : False;
			}
			return result;
		}

		// <=

		inline vector<uint8_t> operator<=(vector<uint64_t>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);
				__m256i b = _mm256_loadu_epi64(&data2[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpgt_epi64(a, b), minus_ones);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<=(uint64_t num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			__m256i minus_ones = _mm256_set1_epi64x(-1);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i a = _mm256_loadu_epi64(&data1[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpgt_epi64(a, b), minus_ones);
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= num ? True : False;
			}
			return result;
		}

		// Functions

		// Pow

		inline vector<uint64_t> pow(uint64_t exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi64x(1);
				__m256i base = _mm256_loadu_epi64(&data1[i]);
				uint64_t exp = exponent;
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = _mm256_mul_epu32(result_pow, base);
					}

					base = _mm256_mul_epu32(base, base);
					exp >>= 1;
				}
				_mm256_storeu_epi64(&dataResult[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				uint64_t result_pow = 1;
				uint64_t base = data1[i];
				uint64_t exp = exponent;
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				dataResult[i] = result_pow;
			}
			return result;
		}

		inline vector<uint64_t> pow(vector<uint64_t>& other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			__m256i one = _mm256_set1_epi64x(1);
			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi64x(1);

				__m256i base = _mm256_loadu_epi64(&data1[i]);
				__m256i exps = _mm256_loadu_epi64(&data2[i]);

				while (_mm256_movemask_epi8(_mm256_cmpgt_epi64(exps, zero))) {
					__m256i mask = _mm256_cmpeq_epi64(_mm256_and_si256(exps, one), one);
					result_pow = _mm256_blendv_epi8(result_pow, _mm256_mul_epu32(result_pow, base), mask);
					base = _mm256_mul_epu32(base, base);
					exps = _mm256_srli_epi64(exps, 1);
				}
				_mm256_storeu_epi64(&dataResult[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				uint64_t result_pow = 1;
				uint64_t base = data1[i];
				uint64_t exp = data2[i];
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				dataResult[i] = result_pow;
			}
			return result;
		}

		inline void self_pow(uint64_t exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi64x(1);
				__m256i base = _mm256_loadu_epi64(&data1[i]);
				uint64_t exp = exponent;
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = _mm256_mul_epu32(result_pow, base);
					}

					base = _mm256_mul_epu32(base, base);
					exp >>= 1;
				}
				_mm256_storeu_epi64(&data1[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				uint64_t result_pow = 1;
				uint64_t base = data1[i];
				uint64_t exp = exponent;
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				data1[i] = result_pow;
			}
		}

		inline void self_pow(vector<uint64_t>& other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			__m256i one = _mm256_set1_epi64x(1);
			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi64x(1);

				__m256i base = _mm256_loadu_epi64(&data1[i]);
				__m256i exps = _mm256_loadu_epi64(&data2[i]);

				while (_mm256_movemask_epi8(_mm256_cmpgt_epi64(exps, zero))) {
					__m256i mask = _mm256_cmpeq_epi64(_mm256_and_si256(exps, one), one);
					result_pow = _mm256_blendv_epi8(result_pow, _mm256_mul_epu32(result_pow, base), mask);
					base = _mm256_mul_epu32(base, base);
					exps = _mm256_srli_epi64(exps, 1);
				}
				_mm256_storeu_epi64(&data1[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				uint64_t result_pow = 1;
				uint64_t base = data1[i];
				uint64_t exp = data2[i];
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				data1[i] = result_pow;
			}
		}

		// <<

		inline vector<uint64_t> operator<<(int shift)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&dataResult[i], _mm256_slli_epi64(_mm256_loadu_epi64(&data1[i]), shift));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				dataResult[i] = data1[i] << shift;
			}
			return result;
		}

		inline vector<uint64_t> operator<<(vector<uint64_t> other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&dataResult[i], _mm256_sllv_epi64(_mm256_loadu_epi64(&data1[i]), _mm256_loadu_epi64(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				dataResult[i] = data1[i] << data2[i];
			}
			return result;
		}

		inline void operator<<=(int shift)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&data1[i], _mm256_slli_epi64(_mm256_loadu_epi64(&data1[i]), shift));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				data1[i] <<= shift;
			}
		}

		inline void operator<<=(vector<uint64_t> other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&data1[i], _mm256_sllv_epi64(_mm256_loadu_epi64(&data1[i]), _mm256_loadu_epi64(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				data1[i] <<= data2[i];
			}
		}

		// >>

		inline vector<uint64_t> operator>>(int shift)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&dataResult[i], _mm256_srli_epi64(_mm256_loadu_epi64(&data1[i]), shift));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				dataResult[i] = data1[i] >> shift;
			}
			return result;
		}

		inline vector<uint64_t> operator>>(vector<uint64_t> other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			vector<uint64_t> result(size);

			uint64_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&dataResult[i], _mm256_srlv_epi64(_mm256_loadu_epi64(&data1[i]), _mm256_loadu_epi64(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				dataResult[i] = data1[i] >> data2[i];
			}
			return result;
		}

		inline void operator>>=(int shift)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&data1[i], _mm256_srli_epi64(_mm256_loadu_epi64(&data1[i]), shift));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				data1[i] >>= shift;
			}
		}

		inline void operator>>=(vector<uint64_t> other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;
			uint64_t* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_storeu_epi64(&data1[i], _mm256_srlv_epi64(_mm256_loadu_epi64(&data1[i]), _mm256_loadu_epi64(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i += 4)
			{
				data1[i] >>= data2[i];
			}
		}

		// Sort

		inline void sort()
		{
			std::sort(this->_data, this->_data + this->_size);
		}

		// Cast

		template<typename T>
		inline vector<T> cast()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			uint64_t* data1 = this->_data;

			vector<T> result(size);

			T* dataResult = result._data;

			if constexpr (std::is_same<T, double>::value)
			{
				masks_uint64_to_double;
				for (size_t i = 0; i < finalPos; i += 4)
				{
					uint64_to_double(_mm256_loadu_epi64(&data1[i]));
					_mm256_store_pd(&dataResult[i], uint64ToDouble);
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<double>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, int>::value)
			{
				__m256i indices = _mm256_setr_epi32(0, 2, 4, 6, 7, 5, 3, 1);

				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm_storeu_epi32(&dataResult[i], _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_loadu_epi64(&data1[i]), indices)));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<int>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, uint8_t>::value)
			{
				__m256d zero = _mm256_setzero_pd();

				for (size_t i = 0; i < finalPos; i += 4)
				{
					__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(_mm256_castsi256_pd(_mm256_loadu_epi64(&data1[i])), zero, _CMP_NEQ_OQ));

					__m128i mask1 = _mm256_castsi256_si128(mask);
					__m128i mask2 = _mm256_extracti128_si256(mask, 1);

					mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
					mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

					__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

					_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? True : False;
				}
			}
			else
			{
				for (size_t i = 0; i < size; i++)
				{
					dataResult[i] = static_cast<T>(data1[i]);
				}
			}
			return result;
		}

	private:
		uint64_t* _data;
		uint64_t* dataToDelete;
		size_t _size;
		size_t finalPos;
	};

	template <>
	class vector<double>
	{
	public:
		inline vector() : _data(nullptr), dataToDelete(nullptr), _size(0), finalPos(0) {}

		inline vector(size_t size) : _data(new double[size]), dataToDelete(_data), _size(size), finalPos((size / 4) * 4) {}

		inline vector(double* data, size_t size) : _data(data), dataToDelete(nullptr), _size(size), finalPos((size / 4) * 4) {}

		inline ~vector() { delete[] this->dataToDelete; }

		// Friend class

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend function

		friend inline vector<double> where(vector<uint8_t>&, vector<double>&, vector<double>&);

		friend inline vector<double> where(vector<uint8_t>&, vector<double>&, double);

		friend inline vector<double> where(vector<uint8_t>&, double, vector<double>&);

		friend inline vector<double> where(vector<uint8_t>&, double, double);

		friend inline double dot(vector<double>&, vector<double>&);

		friend inline vector<double> operator+(double, vector<double>&);

		friend inline vector<double> operator-(double, vector<double>&);

		friend inline vector<double> operator/(double, vector<double>&);

		friend inline vector<double> operator*(double, vector<double>&);

		friend inline vector<uint8_t> operator==(double, vector<double>&);

		friend inline vector<uint8_t> operator!=(double, vector<double>&);

		friend inline vector<uint8_t> operator>(double, vector<double>&);

		friend inline vector<uint8_t> operator>=(double, vector<double>&);

		friend inline vector<uint8_t> operator<(double, vector<double>&);

		friend inline vector<uint8_t> operator<=(double, vector<double>&);

		friend std::ostream& operator<<(std::ostream&, const vector<double>&);

		template<typename T>
		friend inline vector<T> concatenate(vector<T>&, vector<T>&);

		inline double& operator[](size_t index)
		{
			double* data = this->_data;
			return data[index];
		}

		inline const double& operator[](size_t index) const
		{
			double* data = this->_data;
			return data[index];
		}

		inline vector<double> operator[](vector<uint64_t>& indices)
		{
			size_t size = indices._size;

			vector<double> result(size);

			double* data1 = this->_data;

			uint64_t* dataIndices = indices._data;

			double* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[dataIndices[i]];
			}
			return result;
		}

		inline double* data() { return this->_data; }

		inline size_t size() { return this->_size; }

		// Block

		inline vector<double> block(size_t initial, size_t final)
		{
			return vector<double>(
				&this->_data[initial],
				final - initial
			);
		}

		// Copy

		inline vector<double> copy()
		{
			size_t size = this->_size;

			vector<double> result;

			double* data1 = this->_data;

			double* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[i];
			}
			return result;
		}

		// =

		inline vector<double>& operator=(vector<double>& other)
		{
			if (this->_data == nullptr)
			{
				this->_data = other._data;
				other.dataToDelete = nullptr;
				this->dataToDelete = this->_data;
				this->_size = other._size;
				this->finalPos = other.finalPos;
			}
			else
			{
#ifdef _DEBUG
				if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
				size_t size = this->_size;
				double* data1 = this->_data;
				double* data2 = other._data;

				for (size_t i = 0; i < size; i++)
				{
					data1[i] = data2[i];
				}
			}
			return *this;
		}
		
		// Transfer

		inline void transfer(vector<double>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_size = other._size;
			this->finalPos = other.finalPos;
		}

		// Set Constant

		inline void set_const(double num)
		{
			size_t size = this->_size;

			double* data1 = this->_data;

			for (size_t i = 0; i < size; i++)
			{
				data1[i] = num;
			}

		}

		// Rand

		inline void rand()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256i random;

			masks_uint64_to_double;

			__m256d divisor = _mm256_set1_pd(18446744073709551615.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				random = _mm256_slli_epi64(__seeds__, 13);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_srli_epi64(__seeds__, 10);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_slli_epi64(__seeds__, 20);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				// uint64 to double

				uint64_to_double(__seeds__);

				_mm256_store_pd(&data1[i], _mm256_div_pd(uint64ToDouble, divisor));
			}
			
			for (size_t i = finalPos; i < size; i++)
			{
				random = _mm256_slli_epi64(__seeds__, 13);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_srli_epi64(__seeds__, 10);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_slli_epi64(__seeds__, 20);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				// uint64 to double

				uint64_to_double(__seeds__);

				_mm_store_sd(&data1[i], _mm256_castpd256_pd128(_mm256_div_pd(uint64ToDouble, divisor)));
			}
		}

		// neg

		inline vector<double> operator-()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d mask = _mm256_set1_pd(-0.0);

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_xor_pd(_mm256_load_pd(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = -data1[i];
			}
			return result;
		}

		inline void self_neg()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d mask = _mm256_set1_pd(-0.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_xor_pd(_mm256_load_pd(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = -data1[i];
			}
		}

		// +
		
		inline vector<double> operator+(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + data2[i];
			}
			return result;
		}

		inline vector<double> operator+(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + num;
			}
			return result;
		}

		
		inline void operator+=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] + data2[i];
			}
		}

		inline void operator+=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] + num;
			}
		}

		// -

		
		inline vector<double> operator-(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - data2[i];
			}
			return result;
		}

		inline vector<double> operator-(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - num;
			}
			return result;
		}

		
		inline void operator-=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] - data2[i];
			}
		}

		inline void operator-=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] - num;
			}
		}

		// *

		
		inline vector<double> operator*(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * data2[i];
			}
			return result;
		}

		inline vector<double> operator*(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * num;
			}
			return result;
		}

		
		inline void operator*=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] * data2[i];
			}
		}

		inline void operator*=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] * num;
			}
		}

		// /

		
		inline vector<double> operator/(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / data2[i];
			}
			return result;
		}

		inline vector<double> operator/(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / num;
			}
			return result;
		}

		
		inline void operator/=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] / data2[i];
			}
		}

		inline void operator/=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] / num;
			}
		}

		// ==

		inline vector<uint8_t> operator==(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator==(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == num ? True : False;
			}
			return result;
		}

		// !=

		inline vector<uint8_t> operator!=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator!=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != num ? True : False;
			}
			return result;
		}

		// >

		inline vector<uint8_t> operator>(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size > other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}

			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > num ? True : False;
			}
			return result;
		}

		// >=

		
		inline vector<uint8_t> operator>=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= num ? True : False;
			}
			return result;
		}

		// <

		
		inline vector<uint8_t> operator<(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < num ? True : False;
			}
			return result;
		}

		// <=

		
		inline vector<uint8_t> operator<=(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;
			double* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);
				__m256d b = _mm256_load_pd(&data2[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<=(double num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= num ? True : False;
			}
			return result;
		}

		// Functions

		// Pow

		inline vector<double> pow(double exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d _exponet = _mm256_set1_pd(exponent);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _exponet));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], exponent);
			}
			return result;
		}

		inline vector<double> pow(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _mm256_load_pd(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], data2[i]);
			}
			return result;
		}

		inline void self_pow(double exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _exponet = _mm256_set1_pd(exponent);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _exponet));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], exponent);
			}
		}

		inline void self_pow(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			double* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _mm256_load_pd(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], data2[i]);
			}
		}

		// Root

		inline vector<double> root(double index)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			index = 1 / index;

			__m256d _index = _mm256_set1_pd(index);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _index));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], index);
			}
			return result;
		}

		inline vector<double> root(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			double* data2 = other._data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d ones = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _mm256_div_pd(ones, _mm256_load_pd(&data2[i]))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], 1 / data2[i]);
			}
			return result;
		}

		inline void self_root(double index)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			index = 1 / index;

			__m256d _index = _mm256_set1_pd(index);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _index));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], index);
			}
		}

		inline void self_root(vector<double>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			double* data2 = other._data;

			__m256d ones = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_pow_pd(_mm256_load_pd(&data1[i]), _mm256_div_pd(ones, _mm256_load_pd(&data2[i]))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], 1 / data2[i]);
			}
		}

		// Log

		inline vector<double> log()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_log_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log(data1[i]);
			}
			return result;
		}

		inline void self_log()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_log_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log(data1[i]);
			}
		}

		// Log2

		inline vector<double> log2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_log2_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log2(data1[i]);
			}
			return result;
		}

		inline void self_log2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_log2_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log2(data1[i]);
			}
		}

		// Log10

		inline vector<double> log10()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_log10_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log10(data1[i]);
			}
			return result;
		}

		inline void self_log10()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_log10_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log10(data1[i]);
			}
		}

		// Exp

		inline vector<double> exp()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_exp_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::exp(data1[i]);
			}
			return result;
		}

		inline void self_exp()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_exp_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::exp(data1[i]);
			}
		}

		// Exp2

		inline vector<double> exp2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_exp2_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::exp2(data1[i]);
			}
			return result;
		}

		inline void self_exp2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_exp2_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::exp2(data1[i]);
			}
		}

		// Tan

		inline vector<double> tan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_tan_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::tan(data1[i]);
			}
			return result;
		}

		inline void self_tan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_tan_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::tan(data1[i]);
			}
		}

		// Cos

		inline vector<double> cos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_cos_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::cos(data1[i]);
			}
			return result;
		}

		inline void self_cos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_cos_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::cos(data1[i]);
			}
		}

		// Acos

		inline vector<double> acos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_acos_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::acos(data1[i]);
			}
			return result;
		}

		inline void self_acos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_acos_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::acos(data1[i]);
			}
		}

		// Atan

		inline vector<double> atan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_atan_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::atan(data1[i]);
			}
			return result;
		}

		inline void self_atan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_atan_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::atan(data1[i]);
			}
		}

		// Abs
		
		inline vector<double> abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d mask = _mm256_set1_pd(-0.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_andnot_pd(mask, _mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::fabs(data1[i]);
			}
			return result;
		}
		
		inline void self_abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d mask = _mm256_set1_pd(-0.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_andnot_pd(mask, _mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::fabs(data1[i]);
			}
		}

		// Round

		inline vector<double> round()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_round_pd(_mm256_load_pd(&data1[i]), _MM_FROUND_TO_NEAREST_INT));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::round(data1[i]);
			}
			return result;
		}

		inline void self_round()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_round_pd(_mm256_load_pd(&data1[i]), _MM_FROUND_TO_NEAREST_INT));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::round(data1[i]);
			}
		}

		// Floor

		inline vector<double> floor()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_floor_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::floor(data1[i]);
			}
			return result;
		}

		inline void self_floor()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_floor_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::floor(data1[i]);
			}
		}

		// Ceil

		inline vector<double> ceil()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_ceil_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::ceil(data1[i]);
			}
			return result;
		}

		inline void self_ceil()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_ceil_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::ceil(data1[i]);
			}
		}

		// Max

		inline double max()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _max = _mm256_set1_pd(DBL_MIN);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[i]));
			}

			__m128d val1 = _mm256_castpd256_pd128(_max);

			__m128d val2 = _mm256_extractf128_pd(_max, 1);

			val1 = _mm_max_pd(val1, val2);

			val2 = _mm_permute_pd(val1, 0b01);

			val1 = _mm_max_pd(val1, val2);

			double max = _mm_cvtsd_f64(val1);

			for (size_t i = finalPos; i < size; i++)
			{
				double data = data1[i];
				if (data > max) max = data;
			}
			return max;
		}

		inline uint64_t argmax()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _max = _mm256_set1_pd(DBL_MIN);

			double max = DBL_MIN;
			uint64_t indice = 0;

			__m256i indices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i maxIndices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i four = _mm256_set1_epi64x(4);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

				maxIndices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(maxIndices), _mm256_castsi256_pd(indices), mask));

				_max = _mm256_blendv_pd(_max, a, mask);

				indices = _mm256_add_epi64(indices, four);
			}
			uint64_t maxIndicesArr[4];
			double maxArr[4];

			_mm256_storeu_epi64(maxIndicesArr, maxIndices);
			_mm256_store_pd(maxArr, _max);

			for (size_t i = 0; i < 4; i++)
			{
				double data = maxArr[i];
				if (data > max)
				{
					max = data;
					indice = maxIndicesArr[i];
				}
			}
			for (size_t i = finalPos; i < size; i++)
			{
				double data = data1[i];
				if (data > max)
				{
					max = data;
					indice = i;
				}
			}
			return indice;
		}

		// Min

		inline double min()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _min = _mm256_set1_pd(DBL_MAX);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[i]));
			}

			__m256d tempmin = _mm256_permute2f128_pd(_min, _min, 0x01);
			_min = _mm256_min_pd(_min, tempmin);

			__m128d low = _mm256_castpd256_pd128(_min);
			__m128d high = _mm256_extractf128_pd(_min, 1);

			low = _mm_min_pd(low, high);
			double min = _mm_cvtsd_f64(low);

			for (size_t i = finalPos; i < size; i++)
			{
				double data = data1[i];
				if (data > min) min = data;
			}
			return min;
		}

		inline uint64_t argmin()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _min = _mm256_set1_pd(DBL_MAX);

			double min = DBL_MAX;
			uint64_t indice = 0;

			__m256i indices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i minIndices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i four = _mm256_set1_epi64x(4);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

				minIndices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(minIndices), _mm256_castsi256_pd(indices), mask));

				_min = _mm256_blendv_pd(_min, a, mask);

				indices = _mm256_add_epi64(indices, four);
			}
			uint64_t minIndicesArr[4];
			double minArr[4];

			_mm256_storeu_epi64(minIndicesArr, minIndices);
			_mm256_store_pd(minArr, _min);

			for (size_t i = 0; i < 4; i++)
			{
				double data = minArr[i];
				if (data < min)
				{
					min = data;
					indice = minIndicesArr[i];
				}
			}
			for (size_t i = finalPos; i < size; i++)
			{
				double data = data1[i];
				if (data < min)
				{
					min = data;
					indice = i;
				}
			}
			return indice;
		}	

		// Sum

		inline double sum()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i]));
			}


			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			for (size_t i = finalPos; i < size; i++)
			{
				sum += data1[i];
			}

			return sum;
		}

		// Mean

		inline double mean()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i]));
			}


			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			for (size_t i = finalPos; i < size; i++)
			{
				sum += data1[i];
			}

			return sum / static_cast<double>(size);
		}

		// Std

		inline double std(double ddof = 0.0, double* mean = nullptr)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();
			__m256d _sumSquare = _mm256_setzero_pd();

			double size_d = static_cast<double>(size);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_sum = _mm256_add_pd(_sum, a);
				
				_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
			}
			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
			//--
			vlow = _mm256_castpd256_pd128(_sumSquare);
			vhigh = _mm256_extractf128_pd(_sumSquare, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			high64 = _mm_unpackhi_pd(vlow, vlow);
			double sumSquare = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			for (size_t i = finalPos; i < size; i++)
			{
				double data = data1[i];
				sum += data;
				sumSquare += data * data;
			}
			if (mean != nullptr) *mean = sum / size_d;

			double variance = (sumSquare - (sum * sum / size_d)) / (size_d - ddof);
			double std = std::sqrt(variance);
			return std;
		}

		// Activation Functions

		// Tanh

		inline vector<double> tanh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_tanh_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::tanh(data1[i]);
			}
			return result;
		}

		inline void self_tanh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_tanh_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::tanh(data1[i]);
			}
		}

		// Cosh

		inline vector<double> cosh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_cosh_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::cosh(data1[i]);
			}
			return result;
		}

		inline void self_cosh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_cosh_pd(_mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::cosh(data1[i]);
			}
		}

		// ReLU

		inline vector<double> relu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d zero = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_max_pd(zero, _mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::max(0.0, data1[i]);
			}
			return result;
		}

		inline void self_relu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d zero = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_max_pd(zero, _mm256_load_pd(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::max(0.0, data1[i]);
			}
		}

		// LReLU

		inline vector<double> lrelu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d num = _mm256_set1_pd(0.01);

			__m256d zero = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_mm256_mul_pd(a, num), a, _mm256_cmp_pd(a, zero, _CMP_GT_OQ)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > 0.0 ? data1[i] : 0.01 * data1[i];
			}
			return result;
		}

		inline void self_lrelu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d num = _mm256_set1_pd(0.01);

			__m256d zero = _mm256_setzero_pd();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				_mm256_store_pd(&data1[i], _mm256_blendv_pd(_mm256_mul_pd(a, num), a, _mm256_cmp_pd(a, zero, _CMP_GT_OQ)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] > 0.0 ? data1[i] : 0.01 * data1[i];
			}
		}

		// Sigmoid

		inline vector<double> sigmoid()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d mask = _mm256_set1_pd(-0.0);

			__m256d one = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256d neg = _mm256_xor_pd(a, mask);

				__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(neg), one));

				_mm256_store_pd(&dataResult[i], sigmoid);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = 1.0 / (1.0 + std::exp(-data1[i]));
			}
			return result;
		}

		inline void self_sigmoid()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d mask = _mm256_set1_pd(-0.0);

			__m256d one = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256d a = _mm256_load_pd(&data1[i]);

				__m256d neg = _mm256_xor_pd(a, mask);

				__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(neg), one));

				_mm256_store_pd(&data1[i], sigmoid);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = 1.0 / (1.0 + std::exp(-data1[i]));
			}
		}

		// Softplus

		inline vector<double> softplus()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			vector<double> result(size);

			double* dataResult = result._data;

			__m256d one = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&dataResult[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(_mm256_load_pd(&data1[i])))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log(1.0 + std::exp(data1[i]));
			}
			return result;
		}

		inline void self_softplus()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			double* data1 = this->_data;

			__m256d one = _mm256_set1_pd(1.0);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_pd(&data1[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(_mm256_load_pd(&data1[i])))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log(1.0 + std::exp(data1[i]));
			}
		}

		// Softmax

		inline vector<double> softmax()
		{
			vector<double> exp = (this->operator-(this->max())).exp();

			return exp / exp.sum();
		}

		// Sort

		inline void sort() 
		{
			std::sort(this->_data, this->_data + this->_size);
		}

		// Cast

		template <typename T>
		inline vector<T> cast()
		{
			size_t size = this->_size;

			vector<T> result(size);

			double* data1 = this->_data;

			T* dataResult = result._data;

			size_t finalPos = this->finalPos;

			if constexpr (std::is_same<T, uint8_t>::value)
			{
				__m256d zero = _mm256_setzero_pd();

				for (size_t i = 0; i < finalPos; i += 4)
				{
					__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(_mm256_load_pd(&data1[i]), zero, _CMP_NEQ_OQ));

					__m128i mask1 = _mm256_castsi256_si128(mask);
					__m128i mask2 = _mm256_extracti128_si256(mask, 1);

					mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
					mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

					__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

					_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? True : False;
				}
			}
			else if constexpr (std::is_same<T, float>::value)
			{
				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm_store_ps(&dataResult[i], _mm256_cvtpd_ps(_mm256_load_pd(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<float>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, int>::value)
			{
				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm_storeu_epi32(&dataResult[i], _mm256_cvtpd_epi32(_mm256_load_pd(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					double data = data1[i];
					data += 6755399441055744.0;
					dataResult[i] = reinterpret_cast<int&>(data);
				}
			}
			else
			{
				for (size_t i = 0; i < size; i++)
				{
					dataResult[i] = static_cast<T>(data1[i]);
				}
			}
			return result;
		}

	private:
		double* _data;
		double* dataToDelete;
		size_t _size;
		size_t finalPos;
	};

	template <>
	class vector<float>
	{
	public:
		inline vector() : _data(nullptr), dataToDelete(nullptr), _size(0), finalPos(0) {}
		inline vector(size_t size) : _data(new float[size]), dataToDelete(_data), _size(size), finalPos((size / 8) * 8) {}

		inline vector(float* data, size_t size) : _data(data), dataToDelete(nullptr), _size(size), finalPos((size / 8) * 8) {}

		inline ~vector() { delete[] this->dataToDelete; }

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		friend std::ostream& operator<<(std::ostream&, const vector<float>&);

		friend inline vector<float> where(vector<uint8_t>&, vector<float>&, vector<float>&);

		friend inline vector<float> where(vector<uint8_t>&, float, float);

		friend inline vector<float> where(vector<uint8_t>&, vector<float>&, float);

		friend inline vector<float> where(vector<uint8_t>&, float, vector<float>&);

		friend inline float dot(vector<float>&, vector<float>&);

		friend inline vector<float> operator+(float, vector<float>&);

		friend inline vector<float> operator-(float, vector<float>&);

		friend inline vector<float> operator/(float, vector<float>&);

		friend inline vector<float> operator*(float, vector<float>&);

		friend inline vector<uint8_t> operator==(float, vector<float>&);

		friend inline vector<uint8_t> operator!=(float, vector<float>&);

		friend inline vector<uint8_t> operator>(float, vector<float>&);

		friend inline vector<uint8_t> operator>=(float, vector<float>&);

		friend inline vector<uint8_t> operator<(float, vector<float>&);

		friend inline vector<uint8_t> operator<=(float, vector<float>&);

		template<typename T>
		friend inline vector<T> concatenate(vector<T>&, vector<T>&);

		inline float& operator[](size_t index)
		{
			float* data = this->_data;
			return data[index];
		}

		inline const float& operator[](size_t index) const
		{
			float* data = this->_data;
			return data[index];
		}

		inline vector<float> operator[](vector<uint64_t>& indices)
		{
			size_t size = indices._size;

			vector<float> result(size);

			float* data1 = this->_data;

			uint64_t* dataIndices = indices._data;

			float* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[dataIndices[i]];
			}
			return result;
		}

		inline float* data() { return this->_data; }

		// Block

		inline vector<float> block(size_t initial, size_t final)
		{
			return vector<float>(
				&this->_data[initial],
				final - initial
			);
		}

		// Copy

		inline vector<float> copy()
		{
			size_t size = this->_size;

			vector<float> result(size);

			float* data1 = this->_data;

			float* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[i];
			}
			return result;
		}

		// =

		inline vector<float>& operator=(vector<float>& other)
		{
			if (this->_data == nullptr)
			{
				this->_data = other._data;
				other.dataToDelete = nullptr;
				this->dataToDelete = this->_data;
				this->_size = other._size;
				this->finalPos = other.finalPos;
			}
			else
			{
#ifdef _DEBUG
				if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
				size_t size = this->_size;
				float* data1 = this->_data;
				float* data2 = other._data;

				for (size_t i = 0; i < size; i++)
				{
					data1[i] = data2[i];
				}
			}
			return *this;
		}

		inline void transfer(vector<float>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_size = other._size;
			this->finalPos = other.finalPos;
		}

		// neg

		inline vector<float> operator-()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_xor_ps(_mm256_load_ps(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = -data1[i];
			}
			return result;
		}

		inline void self_neg()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_xor_ps(_mm256_load_ps(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = -data1[i];
			}
		}

		// Set Constant

		inline void set_const(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < size; i++)
			{
				data1[i] = num;
			}
		}

		// Rand

		inline void rand()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256i random;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				random = _mm256_slli_epi32(__seeds__, 6);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_srli_epi32(__seeds__, 5);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_slli_epi32(__seeds__, 10);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				// uint32 to double

				uint32_to_float(__seeds__);

				_mm256_store_ps(&data1[i], uint32ToFloat);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				random = _mm256_slli_epi32(__seeds__, 6);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_srli_epi32(__seeds__, 5);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				random = _mm256_slli_epi64(__seeds__, 10);
				__seeds__ = _mm256_xor_si256(random, __seeds__);

				// uint32 to double

				uint32_to_float(__seeds__);

				_mm_store_ss(&data1[i], _mm256_castps256_ps128(uint32ToFloat));
			}
		}

		// +

		inline vector<float> operator+(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + data2[i];
			}
			return result;
		}

		inline vector<float> operator+(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + num;
			}
			return result;
		}

		inline void operator+=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] + data2[i];
			}
		}

		inline void operator+=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] + num;
			}
		}

		// -

		inline vector<float> operator-(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - data2[i];
			}
			return result;
		}

		inline vector<float> operator-(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - num;
			}
			return result;
		}

		inline void operator-=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] - data2[i];
			}
		}

		inline void operator-=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] - num;
			}
		}

		// *

		inline vector<float> operator*(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * data2[i];
			}
			return result;
		}

		inline vector<float> operator*(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * num;
			}
			return result;
		}

		inline void operator*=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] * data2[i];
			}
		}

		inline void operator*=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] * num;
			}
		}

		// /

		inline vector<float> operator/(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / data2[i];
			}
			return result;
		}

		inline vector<float> operator/(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / num;
			}
			return result;
		}

		inline void operator/=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] / data2[i];
			}
		}

		inline void operator/=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] / num;
			}
		}

		// ==

		inline vector<uint8_t> operator==(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator==(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == num ? True : False;
			}
			return result;
		}

		// !=

		inline vector<uint8_t> operator!=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator!=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != num ? True : False;
			}
			return result;
		}

		// >

		inline vector<uint8_t> operator>(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > num ? True : False;
			}
			return result;
		}

		// >=

		inline vector<uint8_t> operator>=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= num ? True : False;
			}
			return result;
		}

		// <

		inline vector<uint8_t> operator<(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < num ? True : False;
			}
			return result;
		}

		// <=

		inline vector<uint8_t> operator<=(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;
			float* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);
				__m256 b = _mm256_load_ps(&data2[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<=(float num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));
				__m128i mask1 = _mm256_castsi256_si128(mask);
				__m128i mask2 = _mm256_extracti128_si256(mask, 1);

				mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
				mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

				__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

				_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= num ? True : False;
			}
			return result;
		}

		// Functions

		// Pow

		inline vector<float> pow(float exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 _exponet = _mm256_set1_ps(exponent);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _exponet));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], exponent);
			}
			return result;
		}

		inline vector<float> pow(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _mm256_load_ps(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], data2[i]);
			}
			return result;
		}

		inline void self_pow(float exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _exponet = _mm256_set1_ps(exponent);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _exponet));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], exponent);
			}
		}

		inline void self_pow(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			float* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _mm256_load_ps(&data2[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], data2[i]);
			}
		}

		// Root

		inline vector<float> root(float index)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			index = 1 / index;

			__m256 _index = _mm256_set1_ps(index);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _index));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], index);
			}
			return result;
		}

		inline vector<float> root(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			float* data2 = other._data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 ones = _mm256_set1_ps(1.0);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _mm256_div_ps(ones, _mm256_load_ps(&data2[i]))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::pow(data1[i], 1 / data2[i]);
			}
			return result;
		}

		inline void self_root(float index)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			index = 1 / index;

			__m256 _index = _mm256_set1_ps(index);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _index));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], index);
			}
		}

		inline void self_root(vector<float>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			float* data2 = other._data;

			__m256 ones = _mm256_set1_ps(1.0);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_pow_ps(_mm256_load_ps(&data1[i]), _mm256_div_ps(ones, _mm256_load_ps(&data2[i]))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::pow(data1[i], 1 / data2[i]);
			}
		}

		// Log

		inline vector<float> log()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_log_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log(data1[i]);
			}
			return result;
		}

		inline void self_log()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_log_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log(data1[i]);
			}
		}

		// Log2

		inline vector<float> log2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_log2_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log2(data1[i]);
			}
			return result;
		}

		inline void self_log2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_log2_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log2(data1[i]);
			}
		}

		// Log10

		inline vector<float> log10()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_log10_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log10(data1[i]);
			}
			return result;
		}

		inline void self_log10()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_log10_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log10(data1[i]);
			}
		}

		// Exp

		inline vector<float> exp()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_exp_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::exp(data1[i]);
			}
			return result;
		}

		inline void self_exp()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_exp_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::exp(data1[i]);
			}
		}

		// Exp2

		inline vector<float> exp2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_exp2_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::exp2(data1[i]);
			}
			return result;
		}

		inline void self_exp2()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_exp2_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::exp2(data1[i]);
			}
		}

		// Tan

		inline vector<float> tan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_tan_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::tan(data1[i]);
			}
			return result;
		}

		inline void self_tan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_tan_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::tan(data1[i]);
			}
		}

		// Cos

		inline vector<float> cos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_cos_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::cos(data1[i]);
			}
			return result;
		}

		inline void self_cos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_cos_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::cos(data1[i]);
			}
		}

		// Acos

		inline vector<float> acos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_acos_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::acos(data1[i]);
			}
			return result;
		}

		inline void self_acos()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_acos_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::acos(data1[i]);
			}
		}

		// Atan

		inline vector<float> atan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_atan_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::atan(data1[i]);
			}
			return result;
		}

		inline void self_atan()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_atan_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::atan(data1[i]);
			}
		}

		// Abs

		inline vector<float> abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_andnot_ps(mask, _mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::fabs(data1[i]);
			}
			return result;
		}

		inline void self_abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_andnot_ps(mask, _mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::fabs(data1[i]);
			}
		}

		// Round

		inline vector<float> round()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_round_ps(_mm256_load_ps(&data1[i]), _MM_FROUND_TO_NEAREST_INT));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::round(data1[i]);
			}
			return result;
		}

		inline void self_round()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_round_ps(_mm256_load_ps(&data1[i]), _MM_FROUND_TO_NEAREST_INT));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::round(data1[i]);
			}
		}

		// Floor

		inline vector<float> floor()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_floor_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::floor(data1[i]);
			}
			return result;
		}

		inline void self_floor()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_floor_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::floor(data1[i]);
			}
		}

		// Ceil

		inline vector<float> ceil()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&dataResult[i], _mm256_ceil_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::ceil(data1[i]);
			}
			return result;
		}

		inline void self_ceil()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_store_ps(&data1[i], _mm256_ceil_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::ceil(data1[i]);
			}
		}

		// Max

		inline float max()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _max = _mm256_set1_ps(FLT_MIN);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[i]));
			}

			__m128 val1 = _mm256_castps256_ps128(_max);

			__m128 val2 = _mm256_extractf128_ps(_max, 1);

			val1 = _mm_max_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b1110);

			val1 = _mm_max_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b11100001);

			val1 = _mm_max_ps(val1, val2);

			float max = _mm_cvtss_f32(val1);

			for (size_t i = finalPos; i < size; i++)
			{
				float data = data1[i];
				if (data > max) max = data;
			}
			return max;
		}

		inline uint64_t argmax()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m128 _max = _mm_set1_ps(FLT_MIN);

			float max = FLT_MIN;
			uint64_t indice = 0;

			__m256i indices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i maxIndices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i four = _mm256_set1_epi64x(4);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m128 a = _mm_load_ps(&data1[i]);

				__m128 mask = _mm_cmp_ps(a, _max, _CMP_GT_OQ);

				maxIndices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(maxIndices), _mm256_castsi256_pd(indices), _mm256_castsi256_pd(_mm256_cvtepi32_epi64(_mm_castps_si128(mask)))));

				_max = _mm_blendv_ps(_max, a, mask);

				indices = _mm256_add_epi64(indices, four);
			}
			uint64_t maxIndicesArr[4];
			float maxArr[4];

			_mm256_storeu_epi64(maxIndicesArr, maxIndices);
			_mm_store_ps(maxArr, _max);

			for (size_t i = 0; i < 4; i++)
			{
				float data = maxArr[i];
				if (data > max)
				{
					max = data;
					indice = maxIndicesArr[i];
				}
			}
			for (size_t i = finalPos; i < size; i++)
			{
				float data = data1[i];
				if (data > max)
				{
					max = data;
					indice = i;
				}
			}
			return indice;
		}

		// Min

		inline float min()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _min = _mm256_set1_ps(FLT_MIN);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[i]));
			}

			__m128 val1 = _mm256_castps256_ps128(_min);

			__m128 val2 = _mm256_extractf128_ps(_min, 1);

			val1 = _mm_min_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b1110);

			val1 = _mm_min_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b11100001);

			val1 = _mm_min_ps(val1, val2);

			float min = _mm_cvtss_f32(val1);

			for (size_t i = finalPos; i < size; i++)
			{
				float data = data1[i];
				if (data > min) min = data;
			}
			return min;
		}

		inline uint64_t argmin()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m128 _min = _mm_set1_ps(FLT_MIN);

			float min = FLT_MIN;
			uint64_t indice = 0;

			__m256i indices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i minIndices = _mm256_setr_epi64x(0, 1, 2, 3);

			__m256i four = _mm256_set1_epi64x(4);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m128 a = _mm_load_ps(&data1[i]);

				__m128 mask = _mm_cmp_ps(a, _min, _CMP_LT_OQ);

				minIndices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(minIndices), _mm256_castsi256_pd(indices), _mm256_castsi256_pd(_mm256_cvtepi32_epi64(_mm_castps_si128(mask)))));

				_min = _mm_blendv_ps(_min, a, mask);

				indices = _mm256_add_epi64(indices, four);
			}
			uint64_t minIndicesArr[4];
			float minArr[4];

			_mm256_storeu_epi64(minIndicesArr, minIndices);
			_mm_store_ps(minArr, _min);

			for (size_t i = 0; i < 4; i++)
			{
				float data = minArr[i];
				if (data < min)
				{
					min = data;
					indice = minIndicesArr[i];
				}
			}
			for (size_t i = finalPos; i < size; i++)
			{
				float data = data1[i];
				if (data < min)
				{
					min = data;
					indice = i;
				}
			}
			return indice;
		}

		// Sum

		inline float sum()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i]));
			}


			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

			__m128 lo128 = _mm256_castps256_ps128(_sum2);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);

			float sum = _mm_cvtss_f32(result128);

			for (size_t i = finalPos; i < size; i++)
			{
				sum += data1[i];
			}

			return sum;
		}

		// Mean

		inline float mean()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i]));
			}


			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

			__m128 lo128 = _mm256_castps256_ps128(_sum2);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);

			float sum = _mm_cvtss_f32(result128);

			for (size_t i = finalPos; i < size; i++)
			{
				sum += data1[i];
			}

			return sum / static_cast<float>(size);
		}

		// Std

		inline float std(float ddof = 0.0f, float* mean = nullptr)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();
			__m256 _sumSquare = _mm256_setzero_ps();

			float size_f = static_cast<float>(size);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_sum = _mm256_add_ps(_sum, a);
				_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
			}

			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

			__m128 lo128 = _mm256_castps256_ps128(_sum2);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);

			float sum = _mm_cvtss_f32(result128);
			//--

			_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
			_sum2 = _mm256_hadd_ps(_sum1, _sum1);

			lo128 = _mm256_castps256_ps128(_sum2);
			hi128 = _mm256_extractf128_ps(_sum2, 1);
			result128 = _mm_add_ps(lo128, hi128);

			float sumSquare = _mm_cvtss_f32(result128);

			for (size_t i = finalPos; i < size; i++)
			{
				float data = data1[i];
				sum += data;
				sumSquare += data * data;
			}
			if (mean != nullptr) *mean = sum / size_f;

			float variance = (sumSquare - (sum * sum / size_f)) / (size_f - ddof);
			float std = std::sqrt(variance);
			return std;
		}

		// Activation Functions

		// Tanh

		inline vector<float> tanh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&dataResult[i], _mm256_tanh_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::tanh(data1[i]);
			}
			return result;
		}

		inline void self_tanh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&data1[i], _mm256_tanh_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::tanh(data1[i]);
			}
		}

		// Cosh

		inline vector<float> cosh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&dataResult[i], _mm256_cosh_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::cosh(data1[i]);
			}
			return result;
		}

		inline void self_cosh()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&data1[i], _mm256_cosh_ps(_mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::cosh(data1[i]);
			}
		}

		// ReLU

		inline vector<float> relu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 zero = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&dataResult[i], _mm256_max_ps(zero, _mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::max(0.0f, data1[i]);
			}
			return result;
		}

		inline void self_relu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 zero = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&data1[i], _mm256_max_ps(zero, _mm256_load_ps(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::max(0.0f, data1[i]);
			}
		}

		// LReLU

		inline vector<float> lrelu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 num = _mm256_set1_ps(0.01f);

			__m256 zero = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(_mm256_mul_ps(a, num), a, _mm256_cmp_ps(a, zero, _CMP_GT_OQ)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > 0.0f ? data1[i] : 0.01f * data1[i];
			}
			return result;
		}

		inline void self_lrelu()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 num = _mm256_set1_ps(0.01f);

			__m256 zero = _mm256_setzero_ps();

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				_mm256_store_ps(&data1[i], _mm256_blendv_ps(_mm256_mul_ps(a, num), a, _mm256_cmp_ps(a, zero, _CMP_GT_OQ)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = data1[i] > 0.0f ? data1[i] : 0.01f * data1[i];
			}
		}

		// Sigmoid

		inline vector<float> sigmoid()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			__m256 one = _mm256_set1_ps(1.0f);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256 neg = _mm256_xor_ps(a, mask);

				__m256 sigmoid = _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(neg), one));

				_mm256_store_ps(&dataResult[i], sigmoid);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = 1.0f / (1.0f + std::exp(-data1[i]));
			}
			return result;
		}

		inline void self_sigmoid()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			__m256 one = _mm256_set1_ps(1.0f);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256 a = _mm256_load_ps(&data1[i]);

				__m256 neg = _mm256_xor_ps(a, mask);

				__m256 sigmoid = _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(neg), one));

				_mm256_store_ps(&data1[i], sigmoid);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = 1.0f / (1.0f + std::exp(-data1[i]));
			}
		}

		// Softplus

		inline vector<float> softplus()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			vector<float> result(size);

			float* dataResult = result._data;

			__m256 one = _mm256_set1_ps(1.0f);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&dataResult[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(_mm256_load_ps(&data1[i])))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::log(1.0f + std::exp(data1[i]));
			}
			return result;
		}

		inline void self_softplus()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			float* data1 = this->_data;

			__m256 one = _mm256_set1_ps(1.0f);

			for (size_t i = 0; i < finalPos; i += 4)
			{
				_mm256_store_ps(&data1[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(_mm256_load_ps(&data1[i])))));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::log(1.0f + std::exp(data1[i]));
			}
		}

		// Softmax

		inline vector<float> softmax()
		{
			vector<float> exp = ((*this) - this->max()).exp();
			
			return exp / exp.sum();
		}

		// Sort

		inline void sort()
		{
			std::sort(this->_data, this->_data + this->_size);
		}

		// Cast

		template <typename T>
		inline vector<T> cast()
		{
			size_t size = this->_size;

			vector<T> result(size);

			float* data1 = this->_data;

			T* dataResult = result._data;

			size_t finalPos = this->finalPos;

			if constexpr (std::is_same<T, uint8_t>::value)
			{
				__m256 zero = _mm256_setzero_ps();
				__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

				for (size_t i = 0; i < finalPos; i += 8)
				{
					__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(_mm256_load_ps(&data1[i]), zero, _CMP_NEQ_OQ));

					__m256i mask1 = _mm256_packs_epi32(mask, mask);
					__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

					mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

					_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
				}
				for (size_t i = finalPos; i < size; i += 8)
				{
					dataResult[i] = data1[i] != 0.0f ? True : False;
				}
			}
			else if constexpr (std::is_same<T, int>::value)
			{
				for (size_t i = 0; i < finalPos; i += 8)
				{
					_mm256_storeu_epi32(&dataResult[i], _mm256_cvtps_epi32(_mm256_load_ps(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<int>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, double>::value)
			{
				for (size_t i = 0; i < finalPos; i += 8)
				{
					_mm256_store_pd(&dataResult[i], _mm256_cvtps_pd(_mm_load_ps(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<double>(data1[i]);
				}
			}
			else
			{
				for (size_t i = 0; i < size; i++)
				{
					dataResult[i] = static_cast<T>(data1[i]);
				}
			}
			return result;
		}

	private:
		float* _data;
		float* dataToDelete;
		size_t _size;
		size_t finalPos;
	};

	template <>
	class vector<int>
	{
	public:
		inline vector() : _data(nullptr), dataToDelete(nullptr), _size(0), finalPos(0) {}

		inline vector(size_t size) : _data(new int[size]), dataToDelete(_data), _size(size), finalPos((size / 8) * 8) {}

		inline vector(int* data, size_t size) : _data(data), dataToDelete(nullptr), _size(size), finalPos((size / 8) * 8) {}

		inline ~vector() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		friend inline vector<int> where(vector<uint8_t>&, vector<int>&, vector<int>&);

		friend inline vector<int> where(vector<uint8_t>&, int, int);

		friend inline vector<int> where(vector<uint8_t>&, vector<int>&, int);

		friend inline vector<int> where(vector<uint8_t>&, int, vector<int>&);

		friend std::ostream& operator<<(std::ostream& os, const vector<int>& vector);

		template<typename T>
		friend inline vector<T> concatenate(vector<T>& vector1, vector<T>& vector2);

		friend inline vector<int> operator+(int, vector<int>&);

		friend inline vector<int> operator-(int, vector<int>&);

		friend inline vector<int> operator/(int, vector<int>&);

		friend inline vector<int> operator*(int, vector<int>&);

		friend inline vector<uint8_t> operator==(int, vector<int>&);

		friend inline vector<uint8_t> operator!=(int, vector<int>&);

		friend inline vector<uint8_t> operator>(int, vector<int>&);

		friend inline vector<uint8_t> operator>=(int, vector<int>&);

		friend inline vector<uint8_t> operator<(int, vector<int>&);

		friend inline vector<uint8_t> operator<=(int, vector<int>&);

		// -----

		inline int* data() { return this->_data; }

		inline size_t size() { return this->_size; }

		inline int& operator[](size_t index)
		{
			int* data = this->_data;
			return data[index];
		}

		inline const int& operator[](size_t index) const
		{
			int* data = this->_data;
			return data[index];
		}

		inline vector<int> operator[](vector<uint64_t>& indices)
		{
			size_t size = indices._size;

			vector<int> result(size);

			int* data1 = this->_data;

			uint64_t* dataIndices = indices._data;

			int* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[dataIndices[i]];
			}
			return result;
		}

		// Block

		inline vector<int> block(size_t initial, size_t final)
		{
			return vector<int>(
				&this->_data[initial],
				final - initial
			);
		}

		// Copy

		inline vector<int> copy()
		{
			size_t size = this->_size;

			vector<int> result(size);

			int* data1 = this->_data;

			int* dataResult = result._data;

			for (size_t i = 0; i < size; i++)
			{
				dataResult[i] = data1[i];
			}
			return result;
		}

		// =

		inline vector<int>& operator=(vector<int>& other)
		{
			if (this->_data == nullptr)
			{
				this->_data = other._data;
				other.dataToDelete = nullptr;
				this->dataToDelete = this->_data;
				this->_size = other._size;
				this->finalPos = other.finalPos;
			}
			else
			{
#ifdef _DEBUG
				if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
				size_t size = this->_size;
				int* data1 = this->_data;
				int* data2 = other._data;

				for (size_t i = 0; i < size; i++)
				{
					data1[i] = data2[i];
				}
			}
			return *this;
		}

		inline void transfer(vector<int>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_size = other._size;
			this->finalPos = other.finalPos;
		}

		// neg

		inline vector<int> operator-()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			
			__m256i mask = _mm256_set1_epi32(-1);

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_storeu_epi32(&dataResult[i], _mm256_sign_epi32(_mm256_loadu_epi32(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = -data1[i];
			}
			return result;
		}

		inline void self_neg()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			__m256i mask = _mm256_set1_epi32(0x80000000);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_storeu_epi32(&data1[i], _mm256_xor_si256(_mm256_loadu_epi32(&data1[i]), mask));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = -data1[i];
			}
		}

		// Set Constant

		inline void set_const(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			for (size_t i = 0; i < size; i++)
			{
				data1[i] = num;
			}
		}

		// +

		inline vector<int> operator+(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_add_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + data2[i];
			}
			return result;
		}

		inline vector<int> operator+(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_add_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] + num;
			}
			return result;
		}

		inline void operator+=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_add_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] += data2[i];
			}
		}

		inline void operator+=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			__m256i b = _mm256_set1_epi32(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_add_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] += num;
			}
		}

		// -

		inline vector<int> operator-(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_sub_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - data2[i];
			}
			return result;
		}

		inline vector<int> operator-(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_sub_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] - num;
			}
			return result;
		}

		inline void operator-=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_sub_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] -= data2[i];
			}
		}

		inline void operator-=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			__m256i b = _mm256_set1_epi32(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_sub_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] -= num;
			}
		}

		// *

		inline vector<int> operator*(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_mul_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * data2[i];
			}
			return result;
		}

		inline vector<int> operator*(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_mul_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] * num;
			}
			return result;
		}

		inline void operator*=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_mul_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] *= data2[i];
			}
		}

		inline void operator*=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			__m256i b = _mm256_set1_epi32(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_mul_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] *= num;
			}
		}

		// /

		inline vector<int> operator/(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_div_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / data2[i];
			}
			return result;
		}

		inline vector<int> operator/(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&dataResult[i], _mm256_div_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] / num;
			}
			return result;
		}

		inline void operator/=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_div_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] /= data2[i];
			}
		}

		inline void operator/=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			__m256i b = _mm256_set1_epi32(num);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				_mm256_storeu_epi32(&data1[i], _mm256_div_epi32(a, b));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] /= num;
			}
		}

		// ==

		inline vector<uint8_t> operator==(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i mask = _mm256_cmpeq_epi32(a, b);

				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator==(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i mask = _mm256_cmpeq_epi32(a, b);

				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] == num ? True : False;
			}
			return result;
		}

		// !=

		inline vector<uint8_t> operator!=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpeq_epi32(a, b), minus_ones);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator!=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i mask = _mm256_andnot_si256((_mm256_cmpeq_epi32(a, b)), minus_ones);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] != num ? True : False;
			}
			return result;
		}

		// >

		inline vector<uint8_t> operator>(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i mask = _mm256_cmpgt_epi32(a, b);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i mask = _mm256_cmpgt_epi32(a, b);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] > num ? True : False;
			}
			return result;
		}

		// < 

		inline vector<uint8_t> operator<(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i gt = _mm256_cmpgt_epi32(a, b);
				__m256i eq = _mm256_cmpeq_epi32(a, b);

				__m256i mask = _mm256_andnot_si256(gt, _mm256_andnot_si256(eq, minus_ones));
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i gt = _mm256_cmpgt_epi32(a, b);
				__m256i eq = _mm256_cmpeq_epi32(a, b);

				__m256i mask = _mm256_andnot_si256(gt, _mm256_andnot_si256(eq, minus_ones));

				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] < num ? True : False;
			}
			return result;
		}

		// >=

		inline vector<uint8_t> operator>=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i gt = _mm256_cmpgt_epi32(a, b);
				__m256i eq = _mm256_cmpeq_epi32(a, b);

				__m256i mask = _mm256_or_si256(gt, eq);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator>=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i gt = _mm256_cmpgt_epi32(a, b);
				__m256i eq = _mm256_cmpeq_epi32(a, b);

				__m256i mask = _mm256_or_si256(gt, eq);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] >= num ? True : False;
			}
			return result;
		}

		// <=

		inline vector<uint8_t> operator<=(vector<int>& other)
		{
#ifdef _DEBUG
			if (this->_size != other._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);
				__m256i b = _mm256_loadu_epi32(&data2[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpgt_epi32(a, b), minus_ones);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= data2[i] ? True : False;
			}
			return result;
		}

		inline vector<uint8_t> operator<=(int num)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<uint8_t> result(size);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi32(num);

			__m256i minus_ones = _mm256_set1_epi32(-1);

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i a = _mm256_loadu_epi32(&data1[i]);

				__m256i mask = _mm256_andnot_si256(_mm256_cmpgt_epi32(a, b), minus_ones);
				__m256i mask1 = _mm256_packs_epi32(mask, mask);
				__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

				mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

				_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = data1[i] <= num ? True : False;
			}
			return result;
		}

		// Pow

		inline vector<int> pow(int exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				__m256i result_pow = _mm256_set1_epi32(1);
				__m256i base = _mm256_loadu_epi32(&data1[i]);
				int exp = exponent;
				while (exp > 0) 
				{
					if (exp % 2 == 1) 
					{
						result_pow = _mm256_mul_epi32(result_pow, base);
					}

					base = _mm256_mul_epi32(base, base);
					exp >>= 1;
				}
				_mm256_storeu_epi32(&dataResult[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				int result_pow = 1;
				int base = data1[i];
				int exp = exponent;
				while (exp > 0) 
				{
					if (exp % 2 == 1) 
					{
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				dataResult[i] = result_pow;
			}
			return result;
		}

		inline vector<int> pow(vector<int>& other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			vector<int> result(size);

			int* dataResult = result._data;

			__m256i one = _mm256_set1_epi32(1);
			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi32(1);

				__m256i base = _mm256_loadu_epi32(&data1[i]);
				__m256i exps = _mm256_loadu_epi32(&data2[i]);

				while (_mm256_movemask_epi8(_mm256_cmpgt_epi32(exps, zero))) 
				{
					__m256i mask = _mm256_cmpeq_epi32(_mm256_and_si256(exps, one), one);
					result_pow = _mm256_blendv_epi8(result_pow, _mm256_mul_epi32(result_pow, base), mask);
					base = _mm256_mul_epi32(base, base);
					exps = _mm256_srli_epi32(exps, 1);
				}
				_mm256_storeu_epi32(&dataResult[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				int result_pow = 1;
				int base = data1[i];
				int exp = data2[i];
				while (exp > 0) 
				{
					if (exp % 2 == 1) 
					{
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				dataResult[i] = result_pow;
			}
			return result;
		}

		inline void self_pow(int exponent)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi32(1);
				__m256i base = _mm256_loadu_epi32(&data1[i]);
				int exp = exponent;
				while (exp > 0) 
				{
					if (exp % 2 == 1) 
					{
						result_pow = _mm256_mul_epi32(result_pow, base);
					}

					base = _mm256_mul_epi32(base, base);
					exp >>= 1;
				}
				_mm256_storeu_epi32(&data1[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				int result_pow = 1;
				int base = data1[i];
				int exp = exponent;
				while (exp > 0) {
					if (exp % 2 == 1) {
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				data1[i] = result_pow;
			}
		}

		inline void self_pow(vector<int>& other)
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;
			int* data2 = other._data;

			__m256i one = _mm256_set1_epi32(1);
			__m256i zero = _mm256_setzero_si256();

			for (size_t i = 0; i < finalPos; i += 4)
			{
				__m256i result_pow = _mm256_set1_epi32(1);

				__m256i base = _mm256_loadu_epi32(&data1[i]);
				__m256i exps = _mm256_loadu_epi32(&data2[i]);

				while (_mm256_movemask_epi8(_mm256_cmpgt_epi32(exps, zero))) 
				{
					__m256i mask = _mm256_cmpeq_epi32(_mm256_and_si256(exps, one), one);
					result_pow = _mm256_blendv_epi8(result_pow, _mm256_mul_epi32(result_pow, base), mask);
					base = _mm256_mul_epi32(base, base);
					exps = _mm256_srli_epi32(exps, 1);
				}
				_mm256_storeu_epi32(&data1[i], result_pow);
			}
			for (size_t i = finalPos; i < size; i++)
			{
				int result_pow = 1;
				int base = data1[i];
				int exp = data2[i];
				while (exp > 0) 
				{
					if (exp % 2 == 1) 
					{
						result_pow = result_pow * base;
					}

					base = base * base;
					exp >>= 1;
				}
				data1[i] = result_pow;
			}
		}

		// Abs

		inline vector<int> abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			vector<int> result(size);

			int* dataResult = result._data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_storeu_epi32(&dataResult[i], _mm256_abs_epi32(_mm256_loadu_epi32(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				dataResult[i] = std::abs(data1[i]);
			}
			return result;
		}

		inline void self_abs()
		{
			size_t size = this->_size;

			size_t finalPos = this->finalPos;

			int* data1 = this->_data;

			for (size_t i = 0; i < finalPos; i += 8)
			{
				_mm256_storeu_epi32(&data1[i], _mm256_abs_epi32(_mm256_loadu_epi32(&data1[i])));
			}
			for (size_t i = finalPos; i < size; i++)
			{
				data1[i] = std::abs(data1[i]);
			}
		}

		// Sort

		inline void sort()
		{
			std::sort(this->_data, this->_data + this->_size);
		}

		// Cast

		template<typename T>
		inline vector<T> cast()
		{
			size_t size = this->_size;

			int* data1 = this->_data;

			vector<T> result(size);

			T* dataResult = result._data;

			if constexpr (std::is_same<T, uint64_t>::value)
			{
				size_t finalPos = (this->_size / 4) * 4;
				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm256_storeu_epi64(&dataResult[i], _mm256_cvtepi32_epi64(_mm_loadu_epi32(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<uint64_t>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, float>::value)
			{
				size_t finalPos = this->finalPos;
				for (size_t i = 0; i < finalPos; i += 8)
				{
					_mm256_storeu_ps(&dataResult[i], _mm256_cvtepi32_ps(_mm256_loadu_epi32(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<float>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, double>::value)
			{
				size_t finalPos = (this->_size / 4) * 4;
				for (size_t i = 0; i < finalPos; i += 4)
				{
					_mm256_store_pd(&dataResult[i], _mm256_cvtepi32_pd(_mm_loadu_epi32(&data1[i])));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = static_cast<double>(data1[i]);
				}
			}
			else if constexpr (std::is_same<T, uint8_t>::value)
			{
				size_t finalPos = this->finalPos;
				__m256 zero = _mm256_setzero_ps();
				__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);
				for (size_t i = 0; i < finalPos; i += 8)
				{
					__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(_mm256_castsi256_ps(_mm256_loadu_epi32(&data1[i])), zero, _CMP_NEQ_OQ));
					__m256i mask1 = _mm256_packs_epi32(mask, mask);
					__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

					mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

					_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
				}
				for (size_t i = finalPos; i < size; i++)
				{
					dataResult[i] = data1[i] ? True : False;
				}
			}
			else
			{
				for (size_t i = 0; i < size; i++)
				{
					dataResult[i] = static_cast<T>(data1[i]);
				}
			}

			return result;
		}

	private:
		int* _data;
		int* dataToDelete;
		size_t _size;
		size_t finalPos;
	};

	inline vector<uint8_t> vector<uint8_t>::operator[](vector<uint64_t>& indices)
	{
		size_t size = indices._size;

		vector<uint8_t> result(size);

		uint8_t* data1 = this->_data;

		uint64_t* dataIndices = indices._data;

		uint8_t* dataResult = result._data;

		for (size_t i = 0; i < size; i++)
		{
			dataResult[i] = data1[dataIndices[i]];
		}
		return result;
	}

	// Matrix

	template <bool thisTransposed, bool thisContiguous>
	class matrix<double, thisTransposed, thisContiguous>
	{
	public:

		inline matrix() : 
			_data(nullptr), 
			dataToDelete(nullptr), 
			_rows(0), 
			_cols(0),
			_size(0),
			actualRows(0),
			actualCols(0),
			finalPosRows(0),
			finalPosCols(0),
			finalPosSize(0) {}

		inline matrix(size_t rows, size_t cols) :
			_data(new double[rows * cols]),
			dataToDelete(_data),
			_rows(rows),
			_cols(cols),
			_size(rows * cols),
			actualRows(rows),
			actualCols(cols),
			finalPosRows((_rows / 4) * 4), 
			finalPosCols((_cols / 4) * 4),
			finalPosSize(((rows * cols) / 4) * 4) {}

		inline matrix(double* data, size_t rows, size_t cols, size_t actualRows, size_t actualCols) :
			_data(data),
			dataToDelete(nullptr),
			_rows(rows),
			_cols(cols),
			_size(rows * cols),
			actualRows(actualRows),
			actualCols(actualCols),
			finalPosRows((_rows / 4) * 4),
			finalPosCols((_cols / 4) * 4),
			finalPosSize((_size / 4) * 4) {}

		inline ~matrix() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		template<bool returnTransposed, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<double> dot(matrix<double, matrix1Transposed, matrix1Contiguous>&, matrix<double, matrix2Transposed, matrix2Contiguous>&);

		template<bool otherTransposed, bool otherContiguous>
		friend std::ostream& operator<<(std::ostream& os, const matrix<double, otherTransposed, otherContiguous>& matrix);

		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_rowwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_colwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<double> operator+(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<double> operator-(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<double> operator*(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<double> operator/(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator==(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator!=(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator>(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator>=(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator<(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator<=(double, matrix<double, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, double, double);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous, bool matrx3Transposed, bool matrix3Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<double, matrx2Transposed, matrix2Contiguous>&, matrix<double, matrx3Transposed, matrix3Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<double, matrx2Transposed, matrix2Contiguous>&, double);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, double, matrix<double, matrx2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<double> clip(matrix<double, thisTransposed, thisContiguous>&, double, double);

		//----------------

		inline size_t rows() { return this->_rows; }

		inline size_t cols() { return this->_cols; }

		inline double* data() { return this->_data; }

		inline matrix<double, thisTransposed, thisContiguous> row(size_t row)
		{
			if constexpr (thisTransposed)
			{
				return matrix<double, true, thisContiguous>(
					&this->_data[row],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<double, false, thisContiguous>(
					&this->_data[row * this->actualCols],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<double, thisTransposed, thisContiguous> col(size_t col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<double, true, thisContiguous>(
					&this->_data[col * this->actualRows],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<double, false, thisContiguous>(
					&this->_data[col],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<double, !thisTransposed, thisContiguous> tranpose()
		{
			return matrix<double, !thisTransposed, thisContiguous>(
				this->_data,
				this->_cols,
				this->_rows,
				this->actualCols,
				this->actualRows
			);
		}

		template<bool blockContiguous = false>
		inline matrix<double, thisTransposed, thisContiguous && blockContiguous> block(size_t initial_row, size_t initial_col, size_t final_row, size_t final_col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<double, true, thisContiguous && blockContiguous>(
					&this->_data[initial_col * this->actualRows + initial_row],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
			else
			{
				return matrix<double, false, thisContiguous && blockContiguous>(
					&this->_data[initial_row * this->actualCols + initial_col],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
		}

		inline double& operator()(size_t row, size_t col)
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		inline const double& operator()(size_t row, size_t col) const 
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		// Copy

		template<bool returnTransposed = false>
		inline matrix<double> copy()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t actualRows = this->actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[j * actualRows + i];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i];
						}
					}
				}
			}
			else
			{
				size_t actualCols = this->actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * actualCols + j];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j];
						}
					}
				}
			}
			return result;
		}

		// =

		template<bool otherTransposed, bool otherContiguous>
		inline matrix<double, thisTransposed, thisContiguous>& operator=(matrix<double, otherTransposed, otherContiguous>& other)
		{
			if (this->_data == nullptr)
			{
#ifdef _DEBUG
				if (other.dataToDelete == nullptr) throw std::invalid_argument("Error");
#else
#endif
				this->_data = other._data;
				this->dataToDelete = this->_data;
				other.dataToDelete = nullptr;
				this->_size = other._size;
				this->_rows = other._rows;
				this->_cols = other._cols;
				this->finalPosCols = other.finalPosCols;
				this->finalPosRows = other.finalPosRows;
				this->finalPosSize = other.finalPosSize;
			}
			else
			{
#ifdef _DEBUG
				if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif
				size_t rows = this->_rows;
				size_t cols = this->_cols;

				double* data1 = this->_data;
				double* data2 = other._data;

				if constexpr (thisTransposed)
				{
					size_t matrix1ActualRows = this->actualRows;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			return *this;
		}

		// Transfer

		template<bool otherContiguous>
		inline void transfer(matrix<double, thisTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_cols = other._cols;
			this->_rows = other._rows;
			this->_size = other._size;
			this->actualCols = other.actualCols;
			this->actualRows = other.actualRows;
			this->finalPosCols = other.finalPosCols;
			this->finalPosRows = other.finalPosRows;
			this->finalPosSize = other.finalPosSize;
		}

		// neg

		template<bool returnTransposed = false>
		inline matrix<double> operator-()

		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_xor_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = -data1[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_xor_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d neg = _mm256_xor_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(neg, 1);
								__m128d val2 = _mm256_castpd256_pd128(neg);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = -data1[j * matrix1ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_xor_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d neg = _mm256_xor_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(neg, 1);
							__m128d val2 = _mm256_castpd256_pd128(neg);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = -data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_xor_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d neg = _mm256_xor_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(neg, 1);
							__m128d val2 = _mm256_castpd256_pd128(neg);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = -data1[i * matrix1ActualCols + j];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_xor_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = -data1[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_xor_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d neg = _mm256_xor_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(neg, 1);
								__m128d val2 = _mm256_castpd256_pd128(neg);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = -data1[i * matrix1ActualCols + j];
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_neg()

		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_xor_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = -data1[i];
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_xor_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d neg = _mm256_xor_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(neg, 1);
							__m128d val2 = _mm256_castpd256_pd128(neg);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = -data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_xor_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = -data1[i];
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_xor_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d neg = _mm256_xor_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(neg, 1);
							__m128d val2 = _mm256_castpd256_pd128(neg);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = -data1[i * matrix1ActualCols + j];
						}
					}
				}
			}
		}

		// Set constant

		inline void set_const(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				for (size_t i = 0; i < size; i++)
				{
					data1[i] = num;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; i < cols; j++)
					{
						data1[j * matrix1ActualRows + i] = num;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; i < cols; j++)
					{
						data1[i * matrix1ActualCols + j] = num;
					}
				}
			}
		}

		// Rand

		inline void rand()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t matrix1FinalPosRows = this->finalPosRows;
			size_t matrix1FinalPosCols = this->finalPosRows;

			size_t matrix1ActualCols = this->actualCols;
			size_t matrix1ActualRows = this->actualRows;

			double* data1 = this->_data;

			__m256i random;

			masks_uint64_to_double;

			__m256d divisor = _mm256_set1_pd(18446744073709551615.0);

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					random = _mm256_slli_epi64(__seeds__, 13);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_srli_epi64(__seeds__, 10);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_slli_epi64(__seeds__, 20);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					// uint64 to double

					uint64_to_double(__seeds__);

					_mm256_store_pd(&data1[i], _mm256_div_pd(uint64ToDouble, divisor));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					random = _mm256_slli_epi64(__seeds__, 13);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_srli_epi64(__seeds__, 10);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_slli_epi64(__seeds__, 20);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					// uint64 to double

					uint64_to_double(__seeds__);

					_mm_store_sd(&data1[i], _mm256_castpd256_pd128(_mm256_div_pd(uint64ToDouble, divisor)));
				}
			}
			else if constexpr (thisTransposed)
			{

				for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint64 to double

						uint64_to_double(__seeds__);

						_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_div_pd(uint64ToDouble, divisor));
					}
				}
				for (size_t i = matrix1FinalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < matrix1FinalPosCols; j += 4)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						uint64_to_double(__seeds__);

						uint64ToDouble = _mm256_div_pd(uint64ToDouble, divisor);

						__m128d val1 = _mm256_extractf128_pd(uint64ToDouble, 1);
						__m128d val2 = _mm256_castpd256_pd128(uint64ToDouble);

						_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

						_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
					}
					for (size_t j = matrix1FinalPosCols; j < cols; j++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint64 to double

						uint64_to_double(__seeds__);

						_mm_store_sd(&data1[j * matrix1ActualRows + i], _mm256_castpd256_pd128(_mm256_div_pd(uint64ToDouble, divisor)));
					}
				}
			}
			else
			{
				for (size_t j = 0; j < matrix1FinalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint64 to double

						uint64_to_double(__seeds__);

						_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_div_pd(uint64ToDouble, divisor));
					}
				}
				for (size_t j = matrix1FinalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint64 to double

						uint64_to_double(__seeds__);

						uint64ToDouble = _mm256_div_pd(uint64ToDouble, divisor);

						__m128d val1 = _mm256_extractf128_pd(uint64ToDouble, 1);
						__m128d val2 = _mm256_castpd256_pd128(uint64ToDouble);

						_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

						_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
					}
					for (size_t i = matrix1FinalPosRows; i < rows; i++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint64 to double

						uint64_to_double(__seeds__);

						_mm_store_sd(&data1[i * matrix1ActualCols + j], _mm256_castpd256_pd128(_mm256_div_pd(uint64ToDouble, divisor)));
					}
				}
			}
		}

		// Identity

		inline void identity()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						if (i == j)
						{
							data1[j * matrix1ActualRows + i] = 1.0;
						}
						else
						{
							data1[j * matrix1ActualRows + i] = 0.0;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						if (i == j)
						{
							data1[i * matrix1ActualCols + j] = 1.0;
						}
						else
						{
							data1[i * matrix1ActualCols + j] = 0.0;
						}
					}
				}
			}
		}

		// +

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> operator+(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] + data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d add = _mm256_add_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(add, 1);
									__m128d val2 = _mm256_castpd256_pd128(add);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] + data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d add = _mm256_add_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(add, 1);
									__m128d val2 = _mm256_castpd256_pd128(add);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator+=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] += data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_add_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] += data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_add_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] += data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_add_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] += data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] += data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_add_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] += data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> operator+(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] + num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_add_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_add_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] + num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_add_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d add = _mm256_add_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(add, 1);
								__m128d val2 = _mm256_castpd256_pd128(add);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator+=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] += num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_add_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] += num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_add_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] += num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_add_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d add = _mm256_add_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(add, 1);
							__m128d val2 = _mm256_castpd256_pd128(add);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] += num;
						}
					}
				}
			}
		}

		// -

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> operator-(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] - data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d sub = _mm256_sub_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(sub, 1);
									__m128d val2 = _mm256_castpd256_pd128(sub);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] - data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d sub = _mm256_sub_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(sub, 1);
									__m128d val2 = _mm256_castpd256_pd128(sub);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator-=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] -= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_sub_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] -= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_sub_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] -= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_sub_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] -= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] -= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_sub_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] -= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> operator-(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] - num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_sub_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] - num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d sub = _mm256_sub_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(sub, 1);
								__m128d val2 = _mm256_castpd256_pd128(sub);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator-=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] -= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_sub_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] -= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_sub_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] -= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_sub_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d sub = _mm256_sub_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] -= num;
						}
					}
				}
			}
		}

		// *

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> operator*(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] * data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d mul = _mm256_mul_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(mul, 1);
									__m128d val2 = _mm256_castpd256_pd128(mul);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] * data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d mul = _mm256_mul_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(mul, 1);
									__m128d val2 = _mm256_castpd256_pd128(mul);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator*=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] *= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_mul_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] *= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_mul_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] *= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_mul_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] *= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] *= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_mul_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] *= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> operator*(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] * num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_mul_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_mul_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] * num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_mul_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d mul = _mm256_mul_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(mul, 1);
								__m128d val2 = _mm256_castpd256_pd128(mul);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator*=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] *= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_mul_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] *= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_mul_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] *= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_mul_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d mul = _mm256_mul_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(mul, 1);
							__m128d val2 = _mm256_castpd256_pd128(mul);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] *= num;
						}
					}
				}
			}
		}

		// /

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> operator/(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] / data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d div = _mm256_div_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(div, 1);
									__m128d val2 = _mm256_castpd256_pd128(div);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] / data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d div = _mm256_div_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(div, 1);
									__m128d val2 = _mm256_castpd256_pd128(div);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator/=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] /= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_div_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] /= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_div_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] /= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_div_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] /= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] /= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_div_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] /= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> operator/(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] / num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_div_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] / num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d div = _mm256_div_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(div, 1);
								__m128d val2 = _mm256_castpd256_pd128(div);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator/=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] /= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_div_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] /= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_div_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] /= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_div_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d div = _mm256_div_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] /= num;
						}
					}
				}
			}
		}

		// ==

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator==(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] == data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] == data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator==(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] == num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] == num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_EQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// !=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator!=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] != data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] != data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator!=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] != num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] != num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_NEQ_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// >

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator>(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] > data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] > data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator>(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// <

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator<(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] < data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] < data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator<(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] < num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] < num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LT_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// >=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator>=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] >= data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] >= data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator>=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] >= num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] >= num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_GE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// <=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator<=(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] <= data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] <= data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

									__m128i mask1 = _mm256_castsi256_si128(mask);
									__m128i mask2 = _mm256_extracti128_si256(mask, 1);

									mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
									mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

									__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

									_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator<=(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] <= num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[j * rows + i]), _mm_castsi128_ps(maskResult));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i]), _mm_castsi128_ps(maskResult));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] <= num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(a, b, _CMP_LE_OQ));

								__m128i mask1 = _mm256_castsi256_si128(mask);
								__m128i mask2 = _mm256_extracti128_si256(mask, 1);

								mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
								mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

								__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

								_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// Functions

		template<bool returnTransposed = false>
		inline matrix<double> exp()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_exp_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;
						
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_exp_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
									data1[(j + 1) * matrix1ActualRows + i], 
									data1[(j + 2) * matrix1ActualRows + i], 
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_exp_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::exp(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
								data1[(j + 1) * matrix1ActualRows + i], 
								data1[(j + 2) * matrix1ActualRows + i], 
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_exp_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_exp_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::exp(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j], 
								data1[(i + 1) * matrix1ActualCols + j], 
								data1[(i + 2) * matrix1ActualCols + j], 
								data1[(i + 3) * matrix1ActualCols + j]);
							
							_mm256_store_pd(&dataResult[j * rows + i], _mm256_exp_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_exp_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::exp(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_exp_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4) 
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_exp_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j], 
									data1[(i + 2) * matrix1ActualCols + j], 
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_exp_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::exp(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_exp()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_exp_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_exp_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_exp_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::exp(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_exp_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_exp_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_exp_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::exp(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> exp2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_exp2_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_exp2_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_exp2_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::exp2(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_exp2_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_exp2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::exp2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_exp2_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_exp2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::exp2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_exp2_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_exp2_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_exp2_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::exp2(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_exp2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_exp2_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_exp2_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_exp2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::exp2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_exp2_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_exp2_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_exp2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::exp2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> log()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_log_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_log_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_log_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_log_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_log_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_log_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_log_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::log(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_log_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_log_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_log_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_log_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_log_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_log_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_log_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_log_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_log_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}
		
		template<bool returnTransposed = false>
		inline matrix<double> log2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_log2_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_log2_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_log2_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log2(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_log2_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_log2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_log2_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_log2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::log2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_log2_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_log2_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_log2_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log2(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_log2_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_log2_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_log2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_log2_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_log2_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_log2_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> log10()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_log10_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log10(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_log10_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_log10_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log10(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_log10_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_log10_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log10(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_log10_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_log10_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::log10(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_log10_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log10(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_log10_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_log10_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log10(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log10()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_log10_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log10(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_log10_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_log10_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log10(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_log10_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log10(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_log10_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_log10_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log10(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

#define _mm256_abs_pd(a) _mm256_andnot_pd(mask, (a))

		template<bool returnTransposed = false>
		inline matrix<double> abs()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d mask = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_abs_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::fabs(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_abs_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_abs_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::fabs(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_abs_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_abs_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::fabs(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_abs_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_abs_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::fabs(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_abs_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::fabs(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_abs_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_abs_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::fabs(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_abs()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d mask = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_abs_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::fabs(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_abs_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_abs_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::fabs(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_abs_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::fabs(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_abs_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_abs_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::fabs(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}
		
		template<bool returnTransposed = false>
		inline matrix<double> cos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_cos_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::cos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_cos_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_cos_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::cos(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_cos_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_cos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::cos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_cos_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_cos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::cos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_cos_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::cos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_cos_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_cos_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::cos(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_cos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_cos_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::cos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_cos_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_cos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::cos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_cos_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::cos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_cos_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_cos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::cos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> tan()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_tan_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tan(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_tan_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_tan_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::tan(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_tan_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_tan_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::tan(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_tan_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_tan_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::tan(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_tan_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tan(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_tan_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_tan_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::tan(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_tan()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_tan_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tan(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_tan_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_tan_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::tan(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_tan_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tan(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_tan_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_tan_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::tan(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> acos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_acos_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::acos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_acos_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_acos_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::acos(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_acos_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_acos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::acos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_acos_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_acos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::acos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_acos_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::acos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_acos_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_acos_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::acos(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_acos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_acos_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::acos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_acos_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_acos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::acos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_acos_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::acos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_acos_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_acos_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::acos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> round()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::round(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::round(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::round(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::round(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::round(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::round(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}
		
		inline void self_round()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::round(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::round(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::round(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_TO_NEAREST_INT);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::round(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> floor()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::floor(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::floor(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::floor(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::floor(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::floor(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_FLOOR));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::floor(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_floor()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::floor(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::floor(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_FLOOR));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::floor(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_round_pd(a, _MM_FROUND_FLOOR));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_FLOOR);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::floor(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<double> ceil()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::ceil(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_CEIL));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::ceil(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::ceil(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::ceil(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::ceil(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_round_pd(a, _MM_FROUND_CEIL));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::ceil(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_CEIL()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_CEIL));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::ceil(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::ceil(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_round_pd(a, _MM_FROUND_CEIL));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::ceil(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_round_pd(a, _MM_FROUND_CEIL));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_round_pd(a, _MM_FROUND_CEIL);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::ceil(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// pow

		template<bool returnTransposed = false>
		inline matrix<double> pow(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> pow(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], data2[i]);
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d pow = _mm256_pow_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(pow, 1);
									__m128d val2 = _mm256_castpd256_pd128(pow);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], data2[i]);
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d pow = _mm256_pow_pd(a, b);

									__m128d val1 = _mm256_extractf128_pd(pow, 1);
									__m128d val2 = _mm256_castpd256_pd128(pow);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
								}
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_pow(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
			}
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void self_pow(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], data2[i]);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], data2[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
		}

		// root

		template<bool returnTransposed = false>
		inline matrix<double> root(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			num = 1 / num;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, b);

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<double> root(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d one = _mm256_set1_pd(1.0);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], 1.0 / data2[i]);
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
									__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

									_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < finalPosCols; j += 4)
								{
									__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
										data1[(j + 1) * matrix1ActualRows + i],
										data1[(j + 2) * matrix1ActualRows + i],
										data1[(j + 3) * matrix1ActualRows + i]);
									__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
										data2[(j + 1) * matrix2ActualRows + i],
										data2[(j + 2) * matrix2ActualRows + i],
										data2[(j + 3) * matrix2ActualRows + i]);

									__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

									__m128d val1 = _mm256_extractf128_pd(pow, 1);
									__m128d val2 = _mm256_castpd256_pd128(pow);

									_mm_store_sd(&dataResult[j * rows + i], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

									_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
								}
								for (size_t j = finalPosCols; j < cols; j++)
								{
									dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[j * matrix2ActualRows + i]);
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[j * matrix2ActualRows + i]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);
								_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);
								_mm256_store_pd(&dataResult[j * rows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 4)
							{
								__m256d a = _mm256_load_pd(&data1[i]);
								__m256d b = _mm256_load_pd(&data2[i]);

								_mm256_store_pd(&dataResult[i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], 1 / data2[i]);
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
									__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

									_mm256_store_pd(&dataResult[i * cols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < finalPosRows; i += 4)
								{
									__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
										data1[(i + 1) * matrix1ActualCols + j],
										data1[(i + 2) * matrix1ActualCols + j],
										data1[(i + 3) * matrix1ActualCols + j]);
									__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
										data2[(i + 1) * matrix2ActualCols + j],
										data2[(i + 2) * matrix2ActualCols + j],
										data2[(i + 3) * matrix2ActualCols + j]);

									__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

									__m128d val1 = _mm256_extractf128_pd(pow, 1);
									__m128d val2 = _mm256_castpd256_pd128(pow);

									_mm_store_sd(&dataResult[i * cols + j], val2);
									val2 = _mm_shuffle_pd(val2, val2, 1);
									_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

									_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
									val1 = _mm_shuffle_pd(val1, val1, 1);
									_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
								}
								for (size_t i = finalPosRows; i < rows; i++)
								{
									dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[i * matrix2ActualCols + j]);
								}
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_root(double num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			num = 1.0 / num;

			__m256d b = _mm256_set1_pd(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_pow_pd(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, b);

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
			}
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void self_root(const matrix<double, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;
			double* data2 = other._data;

			__m256d one = _mm256_set1_pd(1.0);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], 1 / data2[i]);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
								__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

								_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);
								__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

								_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);
							__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

							__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0 / data2[i * matrix2ActualCols + j]);
						}
					}
			}
		}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
							__m256d b = _mm256_setr_pd(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i]);
							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);
							__m256d b = _mm256_load_pd(&data2[j * matrix2ActualRows + i]);

							__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

							__m128d val1 = _mm256_extractf128_pd(pow, 1);
							__m128d val2 = _mm256_castpd256_pd128(pow);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[j * matrix2ActualRows + i]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							__m256d b = _mm256_load_pd(&data2[i]);

							_mm256_store_pd(&data1[i], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], 1 / data2[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
								__m256d b = _mm256_load_pd(&data2[i * matrix2ActualCols + j]);

								_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_pow_pd(a, _mm256_div_pd(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);
								__m256d b = _mm256_setr_pd(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j]);

								__m256d pow = _mm256_pow_pd(a, _mm256_div_pd(one, b));

								__m128d val1 = _mm256_extractf128_pd(pow, 1);
								__m128d val2 = _mm256_castpd256_pd128(pow);

								_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

								_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0 / data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
		}

		// Mean 

		inline vector<double> mean_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(rows);

			double* dataResult = result._data;

			double cols_d = static_cast<double>(cols);

			__m256d _cols = _mm256_set1_pd(cols_d);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[i], _mm256_div_pd(_sum, _cols));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
							data1[(j + 1) * matrix1ActualRows + i], 
							data1[(j + 2) * matrix1ActualRows + i], 
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					
					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[i] = sum / cols_d;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[i], _mm256_div_pd(_sum, _cols));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(data1[i * matrix1ActualCols + j]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[i] = sum / cols_d;
				}
			}
			return result;
		}

		inline vector<double> mean_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(cols);

			double* dataResult = result._data;

			double rows_d = static_cast<double>(rows);

			__m256d _rows = _mm256_set1_pd(rows_d);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[j], _mm256_div_pd(_sum, _rows));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[j] = sum / rows_d;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[j], _mm256_div_pd(_sum, _rows));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[j] = sum / rows_d;
				}
			}
			return result;
		}

		inline double mean_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t size = this->_size;

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();
			double sum = 0;

			if constexpr (thisContiguous)
			{
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					sum += data1[i];
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
							data1[(j + 1) * matrix1ActualRows + i], 
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j], 
							data1[(i + 1) * matrix1ActualCols + j], 
							data1[(i + 2) * matrix1ActualCols + j], 
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
				}
			}

			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			sum += _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			return sum / static_cast<double>(size);
		}

		// Sum

		inline vector<double> sum_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(rows);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[i], _sum);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[i] = sum;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[i], _sum);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(data1[i * matrix1ActualCols + j]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[i] = sum;
				}
			}
			return result;
		}

		inline vector<double> sum_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[j], _sum);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[j] = sum;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[j], _sum);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[j] = sum;
				}
			}
			return result;
		}

		inline double sum_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();
			double sum = 0;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					sum += data1[i];
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_pd(_sum, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_sum = _mm256_add_pd(_sum, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
				}
			}

			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			sum += _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			return sum;
		}

		// Std

		inline vector<double> std_rowwise(double ddof = 0.0)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(rows);

			double* dataResult = result._data;

			double cols_d = static_cast<double>(cols);

			__m256d _cols = _mm256_set1_pd(cols_d);
			__m256d _ddof = _mm256_set1_pd(ddof);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;
				
				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					__m256d variance = _mm256_div_pd(_mm256_sub_pd(_sumSquare, _mm256_div_pd(_mm256_mul_pd(_sum, _sum), _cols)), _mm256_sub_pd(_cols, _ddof));
					_mm256_store_pd(&dataResult[i], _mm256_sqrt_pd(variance));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
							data1[(j + 1) * matrix1ActualRows + i], 
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);
						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}

					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					//--
					vlow = _mm256_castpd256_pd128(_sumSquare);
					vhigh = _mm256_extractf128_pd(_sumSquare, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					high64 = _mm_unpackhi_pd(vlow, vlow);
					double sumSquare = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
					double variance = (sumSquare - (sum * sum / cols_d)) / (cols_d - ddof);
					double std = std::sqrt(variance);
					dataResult[i] = std;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;
				
				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j], 
							data1[(i + 1) * matrix1ActualCols + j], 
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
						
					}
					__m256d variance = _mm256_div_pd(_mm256_sub_pd(_sumSquare, _mm256_div_pd(_mm256_mul_pd(_sum, _sum), _cols)), _mm256_sub_pd(_cols, _ddof));
					_mm256_store_pd(&dataResult[i], _mm256_sqrt_pd(variance));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}

					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					//--
					vlow = _mm256_castpd256_pd128(_sumSquare);
					vhigh = _mm256_extractf128_pd(_sumSquare, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					high64 = _mm_unpackhi_pd(vlow, vlow);
					double sumSquare = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
					double variance = (sumSquare - (sum * sum / cols_d)) / (cols_d - ddof);
					double std = std::sqrt(variance);
					dataResult[i] = std;
				}
			}
			return result;
		}

		inline vector<double> std_colwise(double ddof = 0.0)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(cols);

			double* dataResult = result._data;

			double rows_d = static_cast<double>(rows);

			__m256d _rows = _mm256_set1_pd(rows_d);
			__m256d _ddof = _mm256_set1_pd(ddof);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					__m256d variance = _mm256_div_pd(_mm256_sub_pd(_sumSquare, _mm256_div_pd(_mm256_mul_pd(_sum, _sum), _rows)), _mm256_sub_pd(_rows, _ddof));
					_mm256_store_pd(&dataResult[j], _mm256_sqrt_pd(variance));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					//--
					vlow = _mm256_castpd256_pd128(_sumSquare);
					vhigh = _mm256_extractf128_pd(_sumSquare, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					high64 = _mm_unpackhi_pd(vlow, vlow);
					double sumSquare = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
					double variance = (sumSquare - (sum * sum / rows_d)) / (rows_d - ddof);
					double std = std::sqrt(variance);
					dataResult[j] = std;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					__m256d variance = _mm256_div_pd(_mm256_sub_pd(_sumSquare, _mm256_div_pd(_mm256_mul_pd(_sum, _sum), _rows)), _mm256_sub_pd(_rows, _ddof));
					_mm256_store_pd(&dataResult[j], _mm256_sqrt_pd(variance));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _sum = _mm256_setzero_pd();
					__m256d _sumSquare = _mm256_setzero_pd();

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					__m128d vlow = _mm256_castpd256_pd128(_sum);
					__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
					double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
					//--
					vlow = _mm256_castpd256_pd128(_sumSquare);
					vhigh = _mm256_extractf128_pd(_sumSquare, 1);
					vlow = _mm_add_pd(vlow, vhigh);

					high64 = _mm_unpackhi_pd(vlow, vlow);
					double sumSquare = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
					double variance = (sumSquare - (sum * sum / rows_d)) / (rows_d - ddof);
					double std = std::sqrt(variance);
					dataResult[j] = std;
				}
			}
			return result;
		}

		inline double std_all(double ddof = 0.0, double* mean = nullptr)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t size = this->_size;

			double size_d = static_cast<double>(size);

			double* data1 = this->_data;

			__m256d _sum = _mm256_setzero_pd();
			__m256d _sumSquare = _mm256_setzero_pd();

			double sum = 0.0;
			double sumSquare = 0.0;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					__m256d a = _mm256_load_pd(&data1[i]);

					_sum = _mm256_add_pd(_sum, a);
					_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					double data = data1[i];
					sum += data;
					sumSquare += data * data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);
						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);
						_sum = _mm256_add_pd(_sum, a);
						_sumSquare = _mm256_fmadd_pd(a, a, _sumSquare);
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
				}
			}

			__m128d vlow = _mm256_castpd256_pd128(_sum);
			__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
			sum += _mm_cvtsd_f64(_mm_add_sd(vlow, high64));
			//--
			vlow = _mm256_castpd256_pd128(_sumSquare);
			vhigh = _mm256_extractf128_pd(_sumSquare, 1);
			vlow = _mm_add_pd(vlow, vhigh);

			high64 = _mm_unpackhi_pd(vlow, vlow);
			sumSquare += _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

			if (mean != nullptr) *mean = sum / size_d;

			double variance = (sumSquare - (sum * sum / size_d)) / (size_d - ddof);
			double std = std::sqrt(variance);
			return std;
		}

		// Min

		inline vector<double> min_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(rows);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[i], _min);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					__m256d tempMin = _mm256_permute2f128_pd(_min, _min, 0x01);
					_min = _mm256_min_pd(_min, tempMin);

					__m128d low = _mm256_castpd256_pd128(_min);
					__m128d high = _mm256_extractf128_pd(_min, 1);

					low = _mm_min_pd(low, high);
					double min = _mm_cvtsd_f64(low);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
					dataResult[i] = min;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[i], _min);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(data1[i * matrix1ActualCols + j]));
					}
					__m256d tempMin = _mm256_permute2f128_pd(_min, _min, 0x01);
					_min = _mm256_min_pd(_min, tempMin);

					__m128d low = _mm256_castpd256_pd128(_min);
					__m128d high = _mm256_extractf128_pd(_min, 1);

					low = _mm_min_pd(low, high);
					double min = _mm_cvtsd_f64(low);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
					dataResult[i] = min;
				}
			}
			return result;
		}

		inline vector<double> min_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[j], _min);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					__m256d tempMin = _mm256_permute2f128_pd(_min, _min, 0x01);
					_min = _mm256_min_pd(_min, tempMin);

					__m128d low = _mm256_castpd256_pd128(_min);
					__m128d high = _mm256_extractf128_pd(_min, 1);

					low = _mm_min_pd(low, high);
					double min = _mm_cvtsd_f64(low);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
					dataResult[j] = min;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[j], _min);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					__m256d tempMin = _mm256_permute2f128_pd(_min, _min, 0x01);
					_min = _mm256_min_pd(_min, tempMin);

					__m128d low = _mm256_castpd256_pd128(_min);
					__m128d high = _mm256_extractf128_pd(_min, 1);

					low = _mm_min_pd(low, high);
					double min = _mm_cvtsd_f64(low);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
					dataResult[j] = min;
				}
			}
			return result;
		}

		inline double min_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d _min = _mm256_set1_pd(DBL_MAX);
			double min = DBL_MAX;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					double data = data1[i];
					if (data < min) min = data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_pd(_min, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_min = _mm256_min_pd(_min, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
				}
			}

			__m256d tempMin = _mm256_permute2f128_pd(_min, _min, 0x01);
			_min = _mm256_min_pd(_min, tempMin);

			__m128d low = _mm256_castpd256_pd128(_min);
			__m128d high = _mm256_extractf128_pd(_min, 1);

			low = _mm_min_pd(low, high);
			double temp_min_d = _mm_cvtsd_f64(low);

			if (temp_min_d < min) min = temp_min_d;

			return min;
		}

		inline void argmin_all(size_t* row, size_t* col)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256i four = _mm256_set1_epi64x(4);

			__m256d _min = _mm256_set1_pd(DBL_MAX);
			double min = DBL_MAX;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;

				size_t finalPosSize = this->finalPosSize;

				__m256i min_indices = _mm256_setr_epi64x(0, 1, 2, 4);
				size_t min_index = 0;

				__m256i indices = _mm256_setr_epi64x(0, 1, 2, 4);

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					__m256d a = _mm256_load_pd(&data1[i]);

					__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

					min_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

					_min = _mm256_blendv_pd(_min, a, mask);

					indices = _mm256_add_epi64(indices, four);
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					double data = data1[i];
					if (data < min)
					{
						min = data;
						min_index = i;
					}
				}

				double mins_arr[4];
				size_t indices_arr[4];

				_mm256_store_pd(mins_arr, _min);
				_mm256_storeu_epi64(indices_arr, min_indices);

				for (size_t i = 0; i < 4; i++)
				{
					double element = mins_arr[i];
					if (element < min)
					{
						min = element;
						min_index = indices_arr[i];
					}
				}
				if constexpr (thisTransposed)
				{
					*row = min_index % rows;
					*col = min_index / rows;
				}
				else
				{
					*row = min_index / cols;
					*col = min_index % cols;
				}
				
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i _i = _mm256_set1_epi64x(0, 1, 2, 3);
				__m256i _j = _mm256_setzero_si256();

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_min = _mm256_setzero_si256();
				__m256i _j_min = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						int mask = _mm256_movemask_pd(_mm256_cmp_pd(a, _min, _CMP_LT_OQ));

						_i_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_min), _mm256_castsi256_pd(_i), mask));

						_j_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_min), _mm256_castsi256_pd(_j), mask));

						_min = _mm256_blend_pd(_min, a, mask);

						_j = _mm256_add_epi64(_j, one);
					}
					_i = _mm256_add_epi64(_i, four);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				double mins_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm256_store_pd(mins_arr, _min);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					double element = mins_arr[i];
					if (element < min)
					{
						min = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				
				__m256i _i = _mm256_setzero_si256();
				__m256i _j = _mm256_set1_epi64x(0, 1, 2, 3);

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_min = _mm256_setzero_si256();
				__m256i _j_min = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						int mask = _mm256_movemask_pd(_mm256_cmp_pd(a, _min, _CMP_LT_OQ));

						_i_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_min), _mm256_castsi256_pd(_i), mask));

						_j_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_min), _mm256_castsi256_pd(_j), mask));

						_min = _mm256_blend_pd(_min, a, mask);

						_i = _mm256_add_epi64(_i, one);
					}
					_j = _mm256_add_epi64(_j_min, four);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				double mins_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm256_store_pd(mins_arr, _min);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					double element = mins_arr[i];
					if (element < min)
					{
						min = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
		}

		inline vector<uint64_t> argmin_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<uint64_t> result(rows);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

						min_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm256_blendv_pd(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], min_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					double min = DBL_MAX;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j], 
							data1[(i + 1) * matrix1ActualCols + j], 
							data1[(i + 2) * matrix1ActualCols + j], 
							data1[(i + 3) * matrix1ActualCols + j]);

						__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

						min_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm256_blendv_pd(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], min_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					double min = DBL_MAX;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			return result;
		}

		inline vector<uint64_t> argmin_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<uint64_t> result(cols);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i], 
							data1[(j + 1) * matrix1ActualRows + i], 
							data1[(j + 2) * matrix1ActualRows + i], 
							data1[(j + 3) * matrix1ActualRows + i]);

						__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

						min_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm256_blendv_pd(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], min_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					double min = DBL_MAX;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _min = _mm256_set1_pd(DBL_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < cols; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d mask = _mm256_cmp_pd(a, _min, _CMP_LT_OQ);

						min_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm256_blendv_pd(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], min_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					double min = DBL_MAX;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			return result;
		}

		// Max

		inline vector<double> max_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(rows);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[i], _max);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					__m256d tempmax = _mm256_permute2f128_pd(_max, _max, 0x01);
					_max = _mm256_max_pd(_max, tempmax);

					__m128d low = _mm256_castpd256_pd128(_max);
					__m128d high = _mm256_extractf128_pd(_max, 1);

					low = _mm_max_pd(low, high);
					double max = _mm_cvtsd_f64(low);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
					dataResult[i] = max;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[i], _max);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(data1[i * matrix1ActualCols + j]));
					}
					__m256d tempmax = _mm256_permute2f128_pd(_max, _max, 0x01);
					_max = _mm256_max_pd(_max, tempmax);

					__m128d low = _mm256_castpd256_pd128(_max);
					__m128d high = _mm256_extractf128_pd(_max, 1);

					low = _mm_max_pd(low, high);
					double max = _mm_cvtsd_f64(low);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
					dataResult[i] = max;
				}
			}
			return result;
		}

		inline vector<double> max_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<double> result(cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					_mm256_store_pd(&dataResult[j], _max);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
					__m256d tempmax = _mm256_permute2f128_pd(_max, _max, 0x01);
					_max = _mm256_max_pd(_max, tempmax);

					__m128d low = _mm256_castpd256_pd128(_max);
					__m128d high = _mm256_extractf128_pd(_max, 1);

					low = _mm_max_pd(low, high);
					double max = _mm_cvtsd_f64(low);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
					dataResult[j] = max;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_pd(&dataResult[j], _max);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					__m256d tempmax = _mm256_permute2f128_pd(_max, _max, 0x01);
					_max = _mm256_max_pd(_max, tempmax);

					__m128d low = _mm256_castpd256_pd128(_max);
					__m128d high = _mm256_extractf128_pd(_max, 1);

					low = _mm_max_pd(low, high);
					double max = _mm_cvtsd_f64(low);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
					dataResult[j] = max;
				}
			}
			return result;
		}

		inline double max_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d _max = _mm256_set1_pd(DBL_MIN);
			double max = DBL_MIN;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					double data = data1[i];
					if (data > max) max = data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_pd(_max, _mm256_load_pd(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						_max = _mm256_max_pd(_max, _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
				}
			}

			__m256d tempmax = _mm256_permute2f128_pd(_max, _max, 0x01);
			_max = _mm256_max_pd(_max, tempmax);

			__m128d low = _mm256_castpd256_pd128(_max);
			__m128d high = _mm256_extractf128_pd(_max, 1);

			low = _mm_max_pd(low, high);
			double temp_max_d = _mm_cvtsd_f64(low);

			if (temp_max_d > max) max = temp_max_d;

			return max;
		}

		inline void argmax_all(size_t* row, size_t* col)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256i four = _mm256_set1_epi64x(4);

			__m256d _max = _mm256_set1_pd(DBL_MIN);
			double max = DBL_MIN;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;

				size_t finalPosSize = this->finalPosSize;

				__m256i max_indices = _mm256_setr_epi64x(0, 1, 2, 4);
				size_t max_index = 0;

				__m256i indices = _mm256_setr_epi64x(0, 1, 2, 4);

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					__m256d a = _mm256_load_pd(&data1[i]);

					__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

					max_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

					_max = _mm256_blendv_pd(_max, a, mask);

					indices = _mm256_add_epi64(indices, four);
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					double data = data1[i];
					if (data > max)
					{
						max = data;
						max_index = i;
					}
				}

				double maxs_arr[4];
				size_t indices_arr[4];

				_mm256_store_pd(maxs_arr, _max);
				_mm256_storeu_epi64(indices_arr, max_indices);

				for (size_t i = 0; i < 4; i++)
				{
					double data = maxs_arr[i];
					if (data > max)
					{
						max = data;
						max_index = indices_arr[i];
					}
				}
				if constexpr (thisTransposed)
				{
					*row = max_index % rows;
					*col = max_index / rows;
				}
				else
				{
					*row = max_index / cols;
					*col = max_index % cols;
				}

			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i _i = _mm256_set1_epi64x(0, 1, 2, 3);
				__m256i _j = _mm256_setzero_si256();

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_max = _mm256_setzero_si256();
				__m256i _j_max = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						int mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						_i_max = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(_i_max), _mm256_castsi256_pd(_i), mask));

						_j_max = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(_j_max), _mm256_castsi256_pd(_j), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						_j = _mm256_add_epi64(_j, one);
					}
					_i = _mm256_add_epi64(_i, four);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				double maxs_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm256_store_pd(maxs_arr, _max);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					double data = maxs_arr[i];
					if (data > max)
					{
						max = data;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i _i = _mm256_setzero_si256();
				__m256i _j = _mm256_set1_epi64x(0, 1, 2, 3);

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_max = _mm256_setzero_si256();
				__m256i _j_max = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						_i_max = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(_i_max), _mm256_castsi256_pd(_i), mask));

						_j_max = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(_j_max), _mm256_castsi256_pd(_j), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						_i = _mm256_add_epi64(_i, one);
					}
					_j = _mm256_add_epi64(_j_max, four);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				double maxs_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm256_store_pd(maxs_arr, _max);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					double data = maxs_arr[i];
					if (data > max)
					{
						max = data;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
		}

		inline vector<uint64_t> argmax_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<uint64_t> result(rows);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						max_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], max_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					double max = DBL_MIN;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						max_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], max_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					double max = DBL_MIN;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			return result;
		}

		inline vector<uint64_t> argmax_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			vector<uint64_t> result(cols);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						max_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], max_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					double max = DBL_MIN;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					__m256d _max = _mm256_set1_pd(DBL_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < cols; i++)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d mask = _mm256_cmp_pd(a, _max, _CMP_GT_OQ);

						max_indices = _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm256_blendv_pd(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], max_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					double max = DBL_MIN;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						double data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			return result;
		}

		// Activation functions

		// ReLU

		template<bool returnTransposed = false>
		inline matrix<double> relu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d zero = _mm256_setzero_pd();

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_max_pd(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.0, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_max_pd(zero, a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d max = _mm256_max_pd(zero, a);

								__m128d val1 = _mm256_extractf128_pd(max, 1);
								__m128d val2 = _mm256_castpd256_pd128(max);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::max(0.0, data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_max_pd(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d max = _mm256_max_pd(zero, a);

							__m128d val1 = _mm256_extractf128_pd(max, 1);
							__m128d val2 = _mm256_castpd256_pd128(max);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::max(0.0, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_max_pd(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d max = _mm256_max_pd(zero, a);

							__m128d val1 = _mm256_extractf128_pd(max, 1);
							__m128d val2 = _mm256_castpd256_pd128(max);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::max(0.0, data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_max_pd(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.0, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_max_pd(zero, a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d max = _mm256_max_pd(zero, a);

								__m128d val1 = _mm256_extractf128_pd(max, 1);
								__m128d val2 = _mm256_castpd256_pd128(max);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::max(0.0, data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_relu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d zero = _mm256_setzero_pd();

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_max_pd(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.0, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_max_pd(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d max = _mm256_max_pd(zero, a);

							__m128d val1 = _mm256_extractf128_pd(max, 1);
							__m128d val2 = _mm256_castpd256_pd128(max);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::max(0.0, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_max_pd(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.0, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_max_pd(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d max = _mm256_max_pd(zero, a);

							__m128d val1 = _mm256_extractf128_pd(max, 1);
							__m128d val2 = _mm256_castpd256_pd128(max);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::max(0.0, data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// LReLU

		template<bool returnTransposed = false>
		inline matrix<double> lrelu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d _num = _mm256_set1_pd(0.01);
			__m256d _zero = _mm256_setzero_pd();

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > 0.0 ? data1[i] : data1[i] * 0.01;
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

								__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
								__m128d val2 = _mm256_castpd256_pd128(lrelu);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > 0.0 ? data1[j * matrix1ActualRows + i] : data1[j * matrix1ActualRows + i] * 0.01;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

							__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
							__m128d val2 = _mm256_castpd256_pd128(lrelu);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > 0.0 ? data1[j * matrix1ActualRows + i] : data1[j * matrix1ActualRows + i] * 0.01;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

							__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
							__m128d val2 = _mm256_castpd256_pd128(lrelu);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > 0.0 ? data1[i * matrix1ActualCols + j] : data1[i * matrix1ActualCols + j] * 0.01;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > 0.0 ? data1[i] : data1[i] * 0.01;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

								__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
								__m128d val2 = _mm256_castpd256_pd128(lrelu);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > 0.0 ? data1[i * matrix1ActualCols + j] : data1[i * matrix1ActualCols + j] * 0.01;
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_lrelu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d _num = _mm256_set1_pd(0.01);
			__m256d _zero = _mm256_setzero_pd();

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = data1[i] > 0.0 ? data1[i] : data1[i] * 0.01;
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

							__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
							__m128d val2 = _mm256_castpd256_pd128(lrelu);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = data1[j * matrix1ActualRows + i] > 0.0 ? data1[j * matrix1ActualRows + i] : data1[j * matrix1ActualRows + i] * 0.01;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = data1[i] > 0.0 ? data1[i] : data1[i] * 0.01;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d lrelu = _mm256_blendv_pd(_mm256_mul_pd(a, _num), a, _mm256_cmp_pd(a, _zero, _CMP_GT_OQ));

							__m128d val1 = _mm256_extractf128_pd(lrelu, 1);
							__m128d val2 = _mm256_castpd256_pd128(lrelu);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = data1[i * matrix1ActualCols + j] > 0.0 ? data1[i * matrix1ActualCols + j] : data1[i * matrix1ActualCols + j] * 0.01;
						}
					}
				}
			}
		}

		// Sigmoid

		template<bool returnTransposed = false>
		inline matrix<double> sigmoid()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d one = _mm256_set1_pd(1.0);

			__m256d mask = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = 1.0 / (1.0 + std::exp(-data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

								__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
								__m128d val2 = _mm256_castpd256_pd128(sigmoid);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = 1.0 / (1.0 + std::exp(-data1[i]));
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

							__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
							__m128d val2 = _mm256_castpd256_pd128(sigmoid);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = 1.0 / (1.0 + std::exp(-data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

							__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
							__m128d val2 = _mm256_castpd256_pd128(sigmoid);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = 1.0 / (1.0 + std::exp(-data1[i * matrix1ActualCols + j]));
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = 1.0 / (1.0 + std::exp(-data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

								__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
								__m128d val2 = _mm256_castpd256_pd128(sigmoid);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = 1.0 / (1.0 + std::exp(-data1[i * matrix1ActualCols + j]));
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_sigmoid()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d one = _mm256_set1_pd(1.0);

			__m256d mask = _mm256_set1_pd(-0.0);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = 1.0 / (1.0 + std::exp(-data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

							__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
							__m128d val2 = _mm256_castpd256_pd128(sigmoid);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = 1.0 / (1.0 + std::exp(-data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = 1.0 / (1.0 + std::exp(-data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d sigmoid = _mm256_div_pd(one, _mm256_add_pd(_mm256_exp_pd(_mm256_xor_pd(a, mask)), one));

							__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
							__m128d val2 = _mm256_castpd256_pd128(sigmoid);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = 1.0 / (1.0 + std::exp(-data1[i * matrix1ActualCols + j]));
						}
					}
				}
			}
		}

		// Softplus
		
		template<bool returnTransposed = false>
		inline matrix<double> softplus()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			__m256d one = _mm256_set1_pd(1.0);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(1.0 + std::exp(data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d softplus = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

								__m128d val1 = _mm256_extractf128_pd(softplus, 1);
								__m128d val2 = _mm256_castpd256_pd128(softplus);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log(1.0 + std::exp(data1[i]));
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d sigmoid = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

							__m128d val1 = _mm256_extractf128_pd(sigmoid, 1);
							__m128d val2 = _mm256_castpd256_pd128(sigmoid);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log(1.0 + std::exp(data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d softplus = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

							__m128d val1 = _mm256_extractf128_pd(softplus, 1);
							__m128d val2 = _mm256_castpd256_pd128(softplus);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::log(1.0 + std::exp(data1[i * matrix1ActualCols + j]));
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(1.0 + std::exp(data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d softplus = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

								__m128d val1 = _mm256_extractf128_pd(softplus, 1);
								__m128d val2 = _mm256_castpd256_pd128(softplus);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log(1.0 + std::exp(data1[i * matrix1ActualCols + j]));
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_softplus()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			__m256d one = _mm256_set1_pd(1.0);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(1.0 + std::exp(data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d softplus = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

							__m128d val1 = _mm256_extractf128_pd(softplus, 1);
							__m128d val2 = _mm256_castpd256_pd128(softplus);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log(1.0 + std::exp(data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(1.0 + std::exp(data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a))));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d softplus = _mm256_log_pd(_mm256_add_pd(one, _mm256_exp_pd(a)));

							__m128d val1 = _mm256_extractf128_pd(softplus, 1);
							__m128d val2 = _mm256_castpd256_pd128(softplus);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log(1.0 + std::exp(data1[i * matrix1ActualCols + j]));
						}
					}
				}
			}
		}

		// Tanh

		template<bool returnTransposed = false>
		inline matrix<double> tanh()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			matrix<double> result(rows, cols);

			double* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);

							_mm256_store_pd(&dataResult[i], _mm256_tanh_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tanh(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

								_mm256_store_pd(&dataResult[j * rows + i], _mm256_tanh_pd(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i]);

								__m256d exp = _mm256_tanh_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[j * rows + i], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

								_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								dataResult[j * rows + i] = std::tanh(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_tanh_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							__m256d exp = _mm256_tanh_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < cols; i++)
						{
							dataResult[i * cols + j] = std::tanh(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_tanh_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							__m256d exp = _mm256_tanh_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::tanh(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 4)
						{
							__m256d a = _mm256_load_pd(&data1[i]);
							_mm256_store_pd(&dataResult[i], _mm256_tanh_pd(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tanh(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

								_mm256_store_pd(&dataResult[i * cols + j], _mm256_tanh_pd(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < finalPosRows; i += 4)
							{
								__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j]);

								__m256d exp = _mm256_tanh_pd(a);

								__m128d val1 = _mm256_extractf128_pd(exp, 1);
								__m128d val2 = _mm256_castpd256_pd128(exp);

								_mm_store_sd(&dataResult[i * cols + j], val2);
								val2 = _mm_shuffle_pd(val2, val2, 1);
								_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

								_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
								val1 = _mm_shuffle_pd(val1, val1, 1);
								_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								dataResult[i * cols + j] = std::tanh(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_tanh()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			double* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&data1[i], _mm256_tanh_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tanh(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&data1[j * matrix1ActualRows + i], _mm256_tanh_pd(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d exp = _mm256_tanh_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[j * matrix1ActualRows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(j + 1) * matrix1ActualRows + i], val2);

							_mm_store_sd(&data1[(j + 2) * matrix1ActualRows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(j + 3) * matrix1ActualRows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::tanh(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);
						_mm256_store_pd(&data1[i], _mm256_tanh_pd(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tanh(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&data1[i * matrix1ActualCols + j], _mm256_tanh_pd(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d exp = _mm256_tanh_pd(a);

							__m128d val1 = _mm256_extractf128_pd(exp, 1);
							__m128d val2 = _mm256_castpd256_pd128(exp);

							_mm_store_sd(&data1[i * matrix1ActualCols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&data1[(i + 1) * matrix1ActualCols + j], val2);

							_mm_store_sd(&data1[(i + 2) * matrix1ActualCols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&data1[(i + 3) * matrix1ActualCols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::tanh(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// Cast

		template <typename T>
		inline matrix<T> cast()
		{
			size_t cols = this->_cols;
			size_t rows = this->_rows;

			matrix<T> result(rows, cols);

			double* data1 = this->_data;

			T* dataResult = result._data;

			size_t actualCols = this->actualCols;
			size_t actualRows = this->actualRows;

			if constexpr (std::is_same<T, uint8_t>::value)
			{
				if constexpr (thisTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + j] != 0.0 ? True : False;
						}
					}
				}
				else
				{
					__m256d zero = _mm256_setzero_pd();
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256i mask = _mm256_castpd_si256(_mm256_cmp_pd(_mm256_load_pd(&data1[i * actualCols + j]), zero, _CMP_NEQ_OQ));

							__m128i mask1 = _mm256_castsi256_si128(mask);
							__m128i mask2 = _mm256_extracti128_si256(mask, 1);

							mask1 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask1), 0b01111000)), 3);
							mask2 = _mm_srli_si128(_mm_castps_si128(_mm_permute_ps(_mm_castsi128_ps(mask2), 0b01111000)), 1);

							__m128i maskResult = _mm_blend_epi16(mask1, mask2, 0b10);

							_mm_store_ss(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm_castsi128_ps(maskResult));
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] != 0.0 ? True : False;
						}
					}
				}
			}
			else if constexpr (std::is_same<T, float>::value)
			{
				if constexpr (thisTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<float>(data1[j * actualRows + j]);
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							_mm_store_ps(&dataResult[i * cols + j], _mm256_cvtpd_ps(_mm256_load_pd(&data1[i * actualCols + j])));
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<float>(data1[i * actualCols + j]);
						}
					}
				}
			}
			else if constexpr (std::is_same<T, int>::value)
			{
				if constexpr (thisTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<int>(data1[j * actualRows + j]);
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							_mm_store_ps(&dataResult[i * cols + j], _mm256_cvtpd_epi32(_mm256_load_pd(&data1[i * actualCols + j])));
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							double data = data1[i * actualCols + j];
							data += 6755399441055744.0;
							dataResult[i * cols + j] = data;
						}
					}
				}
			}
			else
			{
				if constexpr (thisTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<T>(data1[j * actualRows + j]);
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<T>(data1[i * actualCols + j]);
						}
					}
				}
			}
			return result;
		}

	private:
		double* _data;
		double* dataToDelete;
		size_t _rows, _cols, _size;
		size_t actualRows, actualCols;
		size_t finalPosRows, finalPosCols, finalPosSize;
	};

	template <bool thisTransposed, bool thisContiguous>
	class matrix<uint8_t, thisTransposed, thisContiguous>
	{
	public:
		inline matrix() :
			_data(nullptr),
			dataToDelete(nullptr),
			_rows(0),
			_cols(0),
			_size(0),
			actualRows(0),
			actualCols(0),
			finalPosSize(0),
			finalPosRows(0),
			finalPosCols(0),
			finalPosSize256(0),
			finalPosRows256(0),
			finalPosCols256(0) {}

		inline matrix(size_t rows, size_t cols) : 
			_data(new uint8_t[rows * cols]), 
			dataToDelete(_data),
			_rows(rows), 
			_cols(cols), 
			_size(rows * cols),
			actualRows(rows), 
			actualCols(cols), 
			finalPosSize((_size / 32) * 32),
			finalPosRows((rows / 32) * 32),
			finalPosCols((cols / 32) * 32), 
			finalPosSize256((_size / 256) * 256),
			finalPosRows256((rows / 256) * 256),
			finalPosCols256((cols / 256) * 256) {}

		inline matrix(uint8_t* data, size_t rows, size_t cols, size_t actualRows, size_t actualCols) :
			_data(data), 
			dataToDelete(nullptr),
			_rows(rows),
			_cols(cols),
			_size(rows * cols),
			actualRows(actualRows),
			actualCols(actualCols),
			finalPosSize((_size / 32) * 32),
			finalPosRows((rows / 32) * 32),
			finalPosCols((cols / 32) * 32), 
			finalPosSize256((_size / 256) * 256),
			finalPosRows256((rows / 256) * 256),
			finalPosCols256((cols / 256) * 256) {}

		inline ~matrix() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		template<bool otherTransposed, bool otherContiguous>
		friend std::ostream& operator<<(std::ostream& os, const matrix<uint8_t, otherTransposed, otherContiguous>& matrix);

		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_rowwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_colwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous, bool matrx3Transposed, bool matrix3Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<double, matrx2Transposed, matrix2Contiguous>&, matrix<double, matrx3Transposed, matrix3Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<double, matrx2Transposed, matrix2Contiguous>&, double);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, double, matrix<double, matrx2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous>
		friend inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, double, double);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous, bool matrx3Transposed, bool matrix3Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<float, matrx2Transposed, matrix2Contiguous>&, matrix<float, matrx3Transposed, matrix3Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<float, matrx2Transposed, matrix2Contiguous>&, float);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, float, matrix<float, matrx2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, float, float);

		inline size_t rows() { return this->_rows; };

		inline size_t cols() { return this->_cols; };

		inline uint8_t* data() { return this->_data; };

		inline matrix<uint8_t, thisTransposed, thisContiguous> row(size_t row)
		{
			if constexpr (thisTransposed)
			{
				return matrix<uint8_t, true, thisContiguous>(
					&this->_data[row],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<uint8_t, false, thisContiguous>(
					&this->_data[row * this->actualCols],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<uint8_t, thisTransposed, thisContiguous> col(size_t col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<uint8_t, true, thisContiguous>(
					&this->_data[col * this->actualRows],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<uint8_t, false, thisContiguous>(
					&this->_data[col],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<uint8_t, !thisTransposed, thisContiguous> tranpose()
		{
			return matrix<uint8_t, !thisTransposed, thisContiguous>(
				this->_data,
				this->_cols,
				this->_rows,
				this->actualCols,
				this->actualRows
			);
		}

		template<bool blockContiguous = false>
		inline matrix<uint8_t, thisTransposed, thisContiguous && blockContiguous> block(size_t initial_row, size_t initial_col, size_t final_row, size_t final_col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<uint8_t, true, thisContiguous && blockContiguous>(
					&this->_data[initial_col * this->actualRows + initial_row],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
			else
			{
				return matrix<uint8_t, false, thisContiguous && blockContiguous>(
					&this->_data[initial_row * this->actualCols + initial_col],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
		}

		inline uint8_t& operator()(size_t row, size_t col)
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		inline const uint8_t& operator()(size_t row, size_t col) const
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		// Copy

		template<bool returnTransposed = false>
		inline matrix<uint8_t> copy()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t actualRows = this->actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[j * actualRows + i];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i];
						}
					}
				}
			}
			else
			{
				size_t actualCols = this->actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * actualCols + j];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j];
						}
					}
				}
			}
			return result;
		}

		// = 

		template<bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t, thisTransposed, thisContiguous>& operator=(matrix<uint8_t, otherTransposed, otherContiguous>& other)
		{
			if (this->_data == nullptr)
			{
#ifdef _DEBUG
				if (other.dataToDelete == nullptr) throw std::invalid_argument("Error");
#else
#endif
				this->_data = other._data;
				this->dataToDelete = this->_data;
				other.dataToDelete = nullptr;
				this->_size = other._size;
				this->_rows = other._rows;
				this->_cols = other._cols;
				this->finalPosCols = other.finalPosCols;
				this->finalPosRows = other.finalPosRows;
				this->finalPosSize = other.finalPosSize;
				this->finalPosCols256 = other.finalPosCols256;
				this->finalPosRows256 = other.finalPosRows256;
				this->finalPosActualSize256 = other.finalPosActualSize256;
			}
			else
			{
#ifdef _DEBUG
				if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif
				size_t rows = this->_rows;
				size_t cols = this->_cols;

				uint8_t* data1 = this->_data;
				uint8_t* data2 = other._data;

				if constexpr (thisTransposed)
				{
					size_t matrix1ActualRows = this->actualRows;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			return *this;
		}

		// Transfer

		template<bool otherContiguous>
		inline void transfer(matrix<uint8_t, thisTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_cols = other._cols;
			this->_rows = other._rows;
			this->_size = other._size;
			this->actualCols = other.actualCols;
			this->actualRows = other.actualRows;
			this->finalPosCols = other.finalPosCols;
			this->finalPosRows = other.finalPosRows;
			this->finalPosSize = other.finalPosSize;
			this->finalPosCols256 = other.finalPosCols256;
			this->finalPosRows256 = other.finalPosRows256;
			this->finalPosSize256 = other.finalPosSize256;
		}

		// Set constant

		inline void set_const(uint8_t num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						data1[j * matrix1ActualRows + i] = num;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						data1[i * matrix1ActualCols + j] = num;
					}
				}
			}
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator&&(matrix<uint8_t, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;
			uint8_t* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 32)
							{
								__m256i a = _mm256_loadu_epi8(&data1[i]);
								__m256i b = _mm256_loadu_epi8(&data2[i]);

								_mm256_storeu_epi8(&dataResult[i], _mm256_and_si256(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] & data2[i];
							}
						}
						else
						{
							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							size_t finalPosRows = this->finalPosRows;

							for (size_t i = 0; i < finalPosRows; i += 32)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256i a = _mm256_loadu_epi8(&data1[j * matrix1ActualRows + i]);
									__m256i b = _mm256_loadu_epi8(&data2[j * matrix2ActualRows + i]);

									_mm256_storeu_epi8(&dataResult[j * rows + i], _mm256_and_si256(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] & data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] & data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] & data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] & data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] & data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] & data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] & data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;
							
							for (size_t i = 0; i < finalPosSize; i += 32)
							{
								__m256i a = _mm256_loadu_epi8(&data1[i]);
								__m256i b = _mm256_loadu_epi8(&data2[i]);

								_mm256_storeu_epi8(&dataResult[i], _mm256_and_si256(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] & data2[i];
								
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256i a = _mm256_loadu_epi8(&data1[i * matrix1ActualCols + j]);
									__m256i b = _mm256_loadu_epi8(&data2[i * matrix2ActualCols + j]);

									_mm256_storeu_epi8(&dataResult[i * cols + j], _mm256_and_si256(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] & data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator||(matrix<uint8_t, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;
			uint8_t* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous || otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 32)
							{
								__m256i a = _mm256_loadu_epi8(&data1[i]);
								__m256i b = _mm256_loadu_epi8(&data2[i]);

								_mm256_storeu_epi8(&dataResult[i], _mm256_or_si256(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] | data2[i];
							}
						}
						else
						{
							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							size_t finalPosRows = this->finalPosRows;

							for (size_t i = 0; i < finalPosRows; i += 32)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256i a = _mm256_loadu_epi8(&data1[j * matrix1ActualRows + i]);
									__m256i b = _mm256_loadu_epi8(&data2[j * matrix2ActualRows + i]);

									_mm256_storeu_epi8(&dataResult[j * rows + i], _mm256_or_si256(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] | data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] | data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] | data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] | data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] | data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] | data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] | data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous || otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 32)
							{
								__m256i a = _mm256_loadu_epi8(&data1[i]);
								__m256i b = _mm256_loadu_epi8(&data2[i]);

								_mm256_storeu_epi8(&dataResult[i], _mm256_or_si256(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] | data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 4)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256i a = _mm256_loadu_epi8(&data1[i * matrix1ActualCols + j]);
									__m256i b = _mm256_loadu_epi8(&data2[i * matrix2ActualCols + j]);

									_mm256_storeu_epi8(&dataResult[i * cols + j], _mm256_or_si256(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] | data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator!()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i b = _mm256_set1_epi64x(-1);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 32)
						{
							__m256i a = _mm256_loadu_epi8(&data1[i]);
							_mm256_storeu_epi8(&dataResult[i], _mm256_andnot_si256(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = ~data1[i];
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;

						for (size_t i = 0; i < finalPosRows; i += 32)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256i a = _mm256_loadu_epi8(&data1[j * matrix1ActualRows + i]);
								_mm256_storeu_epi8(&dataResult[j * rows + i], _mm256_andnot_si256(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = ~data1[j * matrix1ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = ~data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = ~data1[i * matrix1ActualCols + j];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 32)
						{
							__m256i a = _mm256_loadu_epi8(&data1[i]);
							_mm256_storeu_epi8(&dataResult[i], _mm256_andnot_si256(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = ~data1[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualRows;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 32)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256d a = _mm256_loadu_epi8(&data1[i * matrix1ActualCols + j]);
								_mm256_storeu_epi8(&dataResult[i * cols + j], _mm256_andnot_si256(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = ~data1[i * matrix1ActualCols + j];
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_not()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			__m256d b = _mm256_set1_epi64x(-1);

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 32)
				{
					__m256d a = _mm256_loadu_epi8(&data1[i]);
					_mm256_storeu_epi8(&data1[i], _mm256_andnot_si256(a, b));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					data1[i] = ~data1[i];
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				for (size_t i = 0; i < finalPosRows; i += 32)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_loadu_epi8(&data1[j * matrix1ActualRows + i]);
						_mm256_storeu_epi8(&data1[j * matrix1ActualRows + i], _mm256_andnot_si256(a, b));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						data1[j * matrix1ActualRows + i] = ~data1[j * matrix1ActualRows + i];
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualRows;

				size_t finalPosCols = this->finalPosCols;

				for (size_t j = 0; j < finalPosCols; j += 32)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_loadu_epi8(&data1[i * matrix1ActualCols + j]);
						_mm256_storeu_epi8(&data1[i * matrix1ActualCols + j], _mm256_andnot_si256(a, b));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						data1[i * matrix1ActualCols + j] = ~data1[i * matrix1ActualCols + j];
					}
				}
			}
		}

		inline size_t count_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			size_t count = 0;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;

				size_t finalPosSize256 = this->finalPosSize256;

				for (size_t i = 0; i < finalPosSize256; i += 256)
				{
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 32])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 64])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 96])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 128])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 160])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 192])));
					count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i + 224])));
				}
				for (size_t i = finalPosSize256; i < size; i++)
				{
					if (data1[i]) count++;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows256 = this->finalPosRows256;

				for (size_t j = 0; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows256; i += 256)
					{
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 32])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 64])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 96])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 128])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 160])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 192])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 224])));
					}
					for (size_t i = finalPosRows256; i < rows; i++)
					{
						if (data1[j * matrix1ActualRows + i]) count++;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t extra_cols = matrix1ActualCols - cols;

				size_t finalPosCols256 = this->finalPosCols256;

				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols256; j += 256)
					{
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 32])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 64])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 96])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 128])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 160])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 192])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 224])));
					}
					for (size_t j = finalPosCols256; j < cols; j++)
					{
						if (data1[i * matrix1ActualCols + j]) count++;
					}
				}
			}
			return count;
		}

		inline vector<uint64_t> count_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			vector<uint64_t> result(cols);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t extra_rows = matrix1ActualRows - rows;

				size_t finalPosRows256 = this->finalPosRows256;

				for (size_t j = 0; j < cols; j++)
				{
					size_t count = 0;
					for (size_t i = 0; i < finalPosRows256; i += 256)
					{
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 32])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 64])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 96])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 128])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 160])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 192])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[j * matrix1ActualRows + i + 224])));
					}
					for (size_t i = finalPosRows256; i < rows; i++)
					{
						if (data1[j * matrix1ActualRows + i]) count++;
					}
					dataResult[j] = count;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				for (size_t j = 0; j < cols; j++)
				{
					size_t count = 0;
					for (size_t i = 0; i < rows; i++)
					{
						if (data1[i * matrix1ActualCols + j]) count++;
					}
					dataResult[j] = count;
				}
			}
			return result;
		}

		inline vector<uint64_t> count_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			uint8_t* data1 = this->_data;

			vector<uint64_t> result(rows);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				for (size_t i = 0; i < rows; i++)
				{
					size_t count = 0;
					for (size_t j = 0; j < cols; j++)
					{
						if (data1[j * matrix1ActualRows + i]) count++;
					}
					dataResult[i] = count;
				}
			}
			else
			{
				
				size_t matrix1ActualCols = this->actualCols;

				size_t extra_cols = matrix1ActualCols - cols;

				size_t finalPosCols256 = this->finalPosCols256;

				for (size_t i = 0; i < rows; i++)
				{
					size_t count = 0;
					for (size_t j = 0; j < finalPosCols256; j += 256)
					{
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 32])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 64])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 96])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 128])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 160])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 192])));
						count += _mm_popcnt_u32(_mm256_movemask_epi8(_mm256_loadu_epi8(&data1[i * matrix1ActualCols + j + 224])));
					}
					for (size_t j = finalPosCols256; j < cols; j++)
					{
						if (data1[i * matrix1ActualCols + j]) count++;
					}
					dataResult[i] = count;
				}
			}
			return result;
		}

		template<typename T>
		inline matrix<T> cast()
		{
			size_t cols = this->_cols;
			size_t rows = this->_rows;

			uint8_t* data1 = this->_data;

			matrix<T> result(rows, cols);

			T* dataResult = result._data;

			if constexpr (sizeof(T) == 4)
			{
				if constexpr (thisTransposed)
				{
					uint32_t one = 0b1;
					uint32_t zero = 0b0;

					size_t actualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i] ? reinterpret_cast<T&>(one) : reinterpret_cast<T&>(zero);
						}
					}
				}
				else
				{
					__m256 _one = _mm256_set1_ps(1.0f);
					__m256 _zero = _mm256_setzero_si256();
					uint32_t one = 0b1;
					uint32_t zero = 0b0;

					size_t actualCols = this->actualCols;

					size_t finalPosCols = (this->_cols / 8) * 8;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							__m256 mask = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_loadu_epi8(&data1[i * actualCols + j])));

							_mm256_store_ps(reinterpret_cast<float*>(&dataResult[i * cols + j]), _mm256_blendv_ps(_zero, _one, mask));
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] ? reinterpret_cast<T&>(one) : reinterpret_cast<T&>(zero);
						}
					}
				}
			}
			else if constexpr (sizeof(T) == 8)
			{
				if constexpr (thisTransposed)
				{
					uint64_t one = 0b1;
					uint64_t zero = 0b0;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i] ? reinterpret_cast<T&>(one) : reinterpret_cast<T&>(zero);
						}
					}
				}
				else
				{
					__m256d _one = _mm256_set1_pd(1.0);
					__m256d _zero = _mm256_setzero_pd();
					uint64_t one = 0b1;
					uint64_t zero = 0b0;

					size_t finalPosCols = (this->_cols / 4) * 4;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d mask = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_loadu_epi8(&data1[i * actualCols + j])));

							_mm256_store_pd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm256_blendv_pd(_zero, _one, mask));
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] ? reinterpret_cast<T&>(one) : reinterpret_cast<T&>(zero);
						}
					}
				}
			}
			return result;
		}

	private:

		uint8_t* _data;
		uint8_t* dataToDelete;
		size_t _rows, _cols, _size;
		size_t actualRows, actualCols;
		size_t finalPosSize, finalPosRows, finalPosCols;
		size_t finalPosSize256, finalPosRows256, finalPosCols256;
	};

	template <bool thisTransposed, bool thisContiguous>
	class matrix<float, thisTransposed, thisContiguous>
	{
	public:

		inline matrix() :
			_data(nullptr),
			dataToDelete(nullptr),
			_rows(0),
			_cols(0),
			_size(0),
			actualRows(0),
			actualCols(0),
			finalPosRows(0),
			finalPosCols(0),
			finalPosSize(0) {}

		inline matrix(size_t rows, size_t cols) :
			_data(new float[rows * cols]), 
			dataToDelete(_data),
			_rows(rows),
			_cols(cols),
			_size(rows * cols),
			actualRows(rows),
			actualCols(cols),
			finalPosRows((_rows / 8) * 8),
			finalPosCols((_cols / 8) * 8),
			finalPosSize((_size / 8) * 8) {}

		inline matrix(float* data, size_t rows, size_t cols, size_t actualRows, size_t actualCols) :
			_data(data), 
			dataToDelete(nullptr),
			_rows(rows),
			_cols(cols),
			_size(rows * cols),
			actualRows(actualRows),
			actualCols(actualCols),
			finalPosRows((_rows / 8) * 8),
			finalPosCols((_cols / 8) * 8),
			finalPosSize((_size / 8) * 8) {}

		inline ~matrix() { delete[] this->dataToDelete; }

		// Friend classes

		template <typename T, bool tranposed, bool contiguous>
		friend class matrix;

		template <typename T>
		friend class vector;

		// Friend functions

		template<bool returnTransposed, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<float> dot(matrix<float, matrix1Transposed, matrix1Contiguous>&, matrix<float, matrix2Transposed, matrix2Contiguous>&);

		template<bool otherTransposed, bool otherContiguous>
		friend std::ostream& operator<<(std::ostream& os, const matrix<float, otherTransposed, otherContiguous>& matrix);
		
		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_rowwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, typename T, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
		friend inline matrix<T> concatenate_colwise(matrix<T, matrix1Transposed, matrix1Contiguous>&, matrix<T, matrix2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<float> operator+(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<float> operator-(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<float> operator*(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<float> operator/(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator==(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator!=(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator>(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator>=(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator<(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<uint8_t> operator<=(float, matrix<float, thisTransposed, thisContiguous>&);

		template<bool returnTransposed, bool thisTransposed, bool thisContiguous>
		friend inline matrix<float> clip(matrix<float, thisTransposed, thisContiguous>&, float, float);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous, bool matrx3Transposed, bool matrix3Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<float, matrx2Transposed, matrix2Contiguous>&, matrix<float, matrx3Transposed, matrix3Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, matrix<float, matrx2Transposed, matrix2Contiguous>&, float);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous
			, bool matrx2Transposed, bool matrix2Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, float, matrix<float, matrx2Transposed, matrix2Contiguous>&);

		template<bool returnTransposed, bool matrx1Transposed, bool matrix1Contiguous>
		friend inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>&, float, float);

		//----------------

		inline size_t rows() { return this->_rows; }

		inline size_t cols() { return this->_cols; }

		inline float* data() { return this->_data; }

		inline matrix<float, thisTransposed, thisContiguous> row(size_t row)
		{
			if constexpr (thisTransposed)
			{
				return matrix<float, true, thisContiguous>(
					&this->_data[row],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<float, false, thisContiguous>(
					&this->_data[row * this->actualCols],
					1,
					this->_cols,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<float, thisTransposed, thisContiguous> col(size_t col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<float, true, thisContiguous>(
					&this->_data[col * this->actualRows],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
			else
			{
				return matrix<float, false, thisContiguous>(
					&this->_data[col],
					this->_rows,
					1,
					this->actualRows,
					this->actualCols);
			}
		}

		inline matrix<float, !thisTransposed, thisContiguous> tranpose()
		{
			return matrix<float, !thisTransposed, thisContiguous>(
				this->_data,
				this->_cols,
				this->_rows,
				this->actualCols,
				this->actualRows
			);
		}

		template<bool blockContiguous = false>
		inline matrix<float, thisTransposed, thisContiguous && blockContiguous> block(size_t initial_row, size_t initial_col, size_t final_row, size_t final_col)
		{
			if constexpr (thisTransposed)
			{
				return matrix<float, true, thisContiguous && blockContiguous>(
					&this->_data[initial_col * this->actualRows + initial_row],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
			else
			{
				return matrix<float, false, thisContiguous && blockContiguous>(
					&this->_data[initial_row * this->actualCols + initial_col],
					final_row - initial_row,
					final_col - initial_col,
					final_row - initial_row,
					final_col - initial_col
				);
			}
		}

		inline float& operator()(size_t row, size_t col)
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		inline const float& operator()(size_t row, size_t col) const
		{
			if constexpr (thisTransposed)
			{
				return this->_data[col * this->actualRows + row];
			}
			else
			{
				return this->_data[row * this->actualCols + col];
			}
		}

		// Indentity

		void identity()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						if (i == j)
						{
							data1[j * matrix1ActualRows + i] = 1.0f;
						}
						else
						{
							data1[j * matrix1ActualRows + i] = 0.0f;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						if (i == j)
						{
							data1[i * matrix1ActualCols + j] = 1.0f;
						}
						else
						{
							data1[i * matrix1ActualCols + j] = 0.0f;
						}
					}
				}
			}
		}

		// Copy

		template<bool returnTransposed = false>
		inline matrix<float> copy()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t actualRows = this->actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[j * actualRows + i];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i];
						}
					}
				}
			}
			else
			{
				size_t actualCols = this->actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * actualCols + j];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j];
						}
					}
				}
			}
			return result;
		}

		// =

		template<bool otherTransposed, bool otherContiguous>
		inline matrix<float, thisTransposed, thisContiguous>& operator=(matrix<float, otherTransposed, otherContiguous>& other)
		{
			if (this->_data == nullptr)
			{
#ifdef _DEBUG
				if (other.dataToDelete == nullptr) throw std::invalid_argument("Error");
#else
#endif
				this->_data = other._data;
				this->dataToDelete = this->_data;
				other.dataToDelete = nullptr;
				this->_size = other._size;
				this->_rows = other._rows;
				this->_cols = other._cols;
				this->finalPosCols = other.finalPosCols;
				this->finalPosRows = other.finalPosRows;
				this->finalPosSize = other.finalPosSize;
			}
			else
			{
#ifdef _DEBUG
				if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif
				size_t rows = this->_rows;
				size_t cols = this->_cols;

				float* data1 = this->_data;
				float* data2 = other._data;

				if constexpr (thisTransposed)
				{
					size_t matrix1ActualRows = this->actualRows;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;
					if constexpr (otherTransposed)
					{
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[i * matrix1ActualCols + j] = data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			return *this;
		}

		// Transfer

		template<bool otherContiguous>
		inline void transfer(matrix<float, thisTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other.dataToDelete == nullptr || (this->dataToDelete == nullptr && this->_data != nullptr)) throw std::invalid_argument("Error");
#else
#endif
			delete[] this->_data;

			this->_data = other._data;
			this->dataToDelete = other._data;
			other.dataToDelete = nullptr;
			this->_cols = other._cols;
			this->_rows = other._rows;
			this->_size = other._size;
			this->actualCols = other.actualCols;
			this->actualRows = other.actualRows;
			this->finalPosCols = other.finalPosCols;
			this->finalPosRows = other.finalPosRows;
			this->finalPosSize = other.finalPosSize;
		}

		// neg

		template<bool returnTransposed = false>
		inline matrix<float> operator-()

		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_xor_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = -data1[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_xor_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = -data1[j * matrix1ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_xor_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = -data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_xor_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = -data1[i * matrix1ActualCols + j];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_xor_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = -data1[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_xor_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = -data1[i * matrix1ActualCols + j];
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_not()

		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_xor_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = -data1[i];
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_xor_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = -data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_xor_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = -data1[i];
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_xor_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = -data1[i * matrix1ActualCols + j];
						}
					}
				}
			}
		}

		// Set constant
		
		inline void set_const(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						data1[j * matrix1ActualRows + i] = num;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						data1[i * matrix1ActualCols + j] = num;
					}
				}
			}
		}

		// Rand

		inline void rand()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t matrix1FinalPosRows = this->finalPosRows;
			size_t matrix1FinalPosCols = this->finalPosRows;

			size_t matrix1ActualCols = this->actualCols;
			size_t matrix1ActualRows = this->actualRows;

			float* data1 = this->_data;

			__m256i random;

			__m256 divisor = _mm256_set1_ps(4294967295.0f);

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					random = _mm256_slli_epi32(__seeds__, 6);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_srli_epi32(__seeds__, 5);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_slli_epi32(__seeds__, 10);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					// uint32 to float

					uint32_to_float(__seeds__);

					_mm256_store_ps(&data1[i], _mm256_div_ps(uint32ToFloat, divisor));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					random = _mm256_slli_epi64(__seeds__, 13);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_srli_epi64(__seeds__, 10);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					random = _mm256_slli_epi64(__seeds__, 20);
					__seeds__ = _mm256_xor_si256(random, __seeds__);

					// uint32 to float

					uint32_to_float(__seeds__);

					_mm_store_ss(&data1[i], _mm256_castps256_ps128(_mm256_div_ps(uint32ToFloat, divisor)));
				}
			}
			else if constexpr (thisTransposed)
			{

				for (size_t i = 0; i < matrix1FinalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint32 to float

						uint32_to_float(__seeds__);

						_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_div_ps(uint32ToFloat, divisor));
					}
				}
				for (size_t i = matrix1FinalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						random = _mm256_slli_epi32(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi32(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi32(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint32 to float

						uint32_to_float(__seeds__);

						_mm_store_sd(&data1[j * matrix1ActualRows + i], _mm256_castpd256_pd128(_mm256_div_ps(uint32ToFloat, divisor)));
					}
				}
			}
			else
			{
				for (size_t j = 0; j < matrix1FinalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						random = _mm256_slli_epi32(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi32(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi32(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint32 to float

						uint32_to_float(__seeds__);

						_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_div_ps(uint32ToFloat, divisor));
					}
				}
				for (size_t j = matrix1FinalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						random = _mm256_slli_epi64(__seeds__, 13);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_srli_epi64(__seeds__, 10);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						random = _mm256_slli_epi64(__seeds__, 20);
						__seeds__ = _mm256_xor_si256(random, __seeds__);

						// uint32 to float

						uint32_to_float(__seeds__);

						_mm_store_sd(&data1[i * matrix1ActualCols + j], _mm256_castpd256_pd128(_mm256_div_ps(uint32ToFloat, divisor)));
					}
				}
			}
		}

		// +

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> operator+(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] + data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_add_ps(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j], 
									data2[(i + 4) * matrix2ActualCols + j], 
									data2[(i + 5) * matrix2ActualCols + j], 
									data2[(i + 6) * matrix2ActualCols + j], 
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_add_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i], 
									data1[(j + 4) * matrix1ActualRows + i], 
									data1[(j + 5) * matrix1ActualRows + i], 
									data1[(j + 6) * matrix1ActualRows + i], 
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_add_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j], 
									data1[(i + 4) * matrix1ActualCols + j], 
									data1[(i + 5) * matrix1ActualCols + j], 
									data1[(i + 6) * matrix1ActualCols + j], 
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_add_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i], 
									data2[(j + 4) * matrix2ActualRows + i], 
									data2[(j + 5) * matrix2ActualRows + i], 
									data2[(j + 6) * matrix2ActualRows + i], 
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_add_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] + data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_add_ps(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator+=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] += data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_add_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] += data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j], 
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_add_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] += data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i], 
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i], 
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_add_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] += data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] += data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_add_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] += data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> operator+(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] + num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_add_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] + num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i], 
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i], 
								data1[(j + 7) * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_add_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] + num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j], 
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j], 
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_add_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] + num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_add_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] + num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_add_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] + num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator+=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] += num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_add_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] += num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_add_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] += num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_add_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] += num;
						}
					}
				}
			}
		}

		// -

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> operator-(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] - data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j],
									data2[(i + 4) * matrix2ActualCols + j],
									data2[(i + 5) * matrix2ActualCols + j],
									data2[(i + 6) * matrix2ActualCols + j],
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i],
									data1[(j + 4) * matrix1ActualRows + i],
									data1[(j + 5) * matrix1ActualRows + i],
									data1[(j + 6) * matrix1ActualRows + i],
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j],
									data1[(i + 4) * matrix1ActualCols + j],
									data1[(i + 5) * matrix1ActualCols + j],
									data1[(i + 6) * matrix1ActualCols + j],
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i],
									data2[(j + 4) * matrix2ActualRows + i],
									data2[(j + 5) * matrix2ActualRows + i],
									data2[(j + 6) * matrix2ActualRows + i],
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;


						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] - data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator-=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] -= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_sub_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] -= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j],
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_sub_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] -= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i],
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i],
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_sub_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] -= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] -= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_sub_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] -= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> operator-(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] - num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_sub_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] - num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator-=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] -= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_sub_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] -= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_sub_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] -= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_sub_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] -= num;
						}
					}
				}
			}
		}

		// *

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> operator*(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] * data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_mul_ps(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j],
									data2[(i + 4) * matrix2ActualCols + j],
									data2[(i + 5) * matrix2ActualCols + j],
									data2[(i + 6) * matrix2ActualCols + j],
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_mul_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i],
									data1[(j + 4) * matrix1ActualRows + i],
									data1[(j + 5) * matrix1ActualRows + i],
									data1[(j + 6) * matrix1ActualRows + i],
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_mul_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j],
									data1[(i + 4) * matrix1ActualCols + j],
									data1[(i + 5) * matrix1ActualCols + j],
									data1[(i + 6) * matrix1ActualCols + j],
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_mul_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i],
									data2[(j + 4) * matrix2ActualRows + i],
									data2[(j + 5) * matrix2ActualRows + i],
									data2[(j + 6) * matrix2ActualRows + i],
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_mul_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;


						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] * data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_mul_ps(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator*=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] *= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_mul_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] *= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j],
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_mul_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] *= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i],
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i],
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_mul_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] *= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] *= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_mul_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] *= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> operator*(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] * num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_mul_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] * num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_mul_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] * num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_mul_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] * num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_mul_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] * num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_mul_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] * num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator*=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] *= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_mul_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] *= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_mul_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] *= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_mul_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] *= num;
						}
					}
				}
			}
		}

		// /

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> operator/(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] / data2[i];
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / data2[j * matrix2ActualRows + i];
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j],
									data2[(i + 4) * matrix2ActualCols + j],
									data2[(i + 5) * matrix2ActualCols + j],
									data2[(i + 6) * matrix2ActualCols + j],
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i],
									data1[(j + 4) * matrix1ActualRows + i],
									data1[(j + 5) * matrix1ActualRows + i],
									data1[(j + 6) * matrix1ActualRows + i],
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j],
									data1[(i + 4) * matrix1ActualCols + j],
									data1[(i + 5) * matrix1ActualCols + j],
									data1[(i + 6) * matrix1ActualCols + j],
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / data2[j * matrix2ActualRows + i];
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i],
									data2[(j + 4) * matrix2ActualRows + i],
									data2[(j + 5) * matrix2ActualRows + i],
									data2[(j + 6) * matrix2ActualRows + i],
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;


						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / data2[i * matrix2ActualCols + j];
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] / data2[i];
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / data2[i * matrix2ActualCols + j];
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void operator/=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] /= data2[i];
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_div_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] /= data2[j * matrix2ActualRows + i];
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j],
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_div_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] /= data2[i * matrix2ActualCols + j];
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i],
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i],
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_div_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] /= data2[j * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] /= data2[i];
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_div_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] /= data2[i * matrix2ActualCols + j];
							}
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> operator/(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] / num;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / num;
							}
						}
					}
				}
				else
				{
					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / num;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / num;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_div_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] / num;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / num;
							}
						}
					}
				}
			}
			return result;
		}

		inline void operator/=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;

					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] /= num;
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_div_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] /= num;
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_div_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] /= num;
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_div_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] /= num;
						}
					}
				}
			}
		}

		// ==

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator==(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] == data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] == data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator==(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] == num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] == num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] == num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] == num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] == num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_EQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] == num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// !=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator!=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] != data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] != data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator!=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] != num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] != num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] != num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] != num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] != num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] != num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// >

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator>(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] > data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] > data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator>(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] > num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] > num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] > num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] > num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] > num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// <

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator<(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] < data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] < data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator<(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] < num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] < num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] < num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] < num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] < num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LT_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] < num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// >=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator>=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] >= data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] >= data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator>=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] >= num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] >= num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] >= num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] >= num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] >= num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_GE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] >= num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// <=

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<uint8_t> operator<=(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] <= data2[i] ? True : False;
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= data2[j * matrix2ActualRows + i] ? True : False;
								}
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
					else
					{
						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= data2[j * matrix2ActualRows + i] ? True : False;
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= data2[i * matrix2ActualCols + j] ? True : False;
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = data1[i] <= data2[i] ? True : False;
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

									__m256i mask1 = _mm256_packs_epi32(mask, mask);
									__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

									mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

									_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= data2[i * matrix2ActualCols + j] ? True : False;
								}
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false>
		inline matrix<uint8_t> operator<=(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<uint8_t> result(rows, cols);

			uint8_t* dataResult = result._data;

			__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] <= num ? True : False;
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[j * rows + i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));

							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] <= num ? True : False;
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] <= num ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] <= num ? True : False;
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = data1[i] <= num ? True : False;
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_LE_OQ));

								__m256i mask1 = _mm256_packs_epi32(mask, mask);
								__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

								mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

								_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] <= num ? True : False;
							}
						}
					}
				}
			}
			return result;
		}

		// Functions

		template<bool returnTransposed = false>
		inline matrix<float> exp()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_exp_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_exp_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::exp(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i], 
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i], 
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_exp_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::exp(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j], 
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j], 
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_exp_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::exp(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_exp_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_exp_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::exp(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_exp()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_exp_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_exp_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::exp(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_exp_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_exp_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::exp(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> exp2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_exp2_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_exp2_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::exp2(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_exp2_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::exp2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_exp2_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::exp2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_exp2_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::exp2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_exp2_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::exp2(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_exp2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_exp2_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_exp2_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::exp2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_exp2_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::exp2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_exp2_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::exp2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> log()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_log_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_log_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_log_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_log_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::log(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_log_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_log_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_log_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_log_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_log_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_log_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> log2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_log2_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_log2_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log2(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_log2_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_log2_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::log2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_log2_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log2(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_log2_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log2(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log2()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_log2_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_log2_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log2(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_log2_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log2(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_log2_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log2(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> log10()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_log10_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log10(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_log10_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log10(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_log10_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log10(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_log10_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::log10(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_log10_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log10(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_log10_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log10(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_log10()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_log10_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log10(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_log10_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log10(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_log10_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log10(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_log10_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log10(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

#define _mm256_abs_ps(a) _mm256_andnot_ps(mask, (a))

		template<bool returnTransposed = false>
		inline matrix<float> abs()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_abs_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::fabs(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_abs_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::fabs(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_abs_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::fabs(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_abs_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::fabs(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_abs_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::fabs(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_abs_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::fabs(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_abs()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 mask = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_abs_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::fabs(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_abs_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::fabs(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_abs_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::fabs(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_abs_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::fabs(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> cos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_cos_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::cos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_cos_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::cos(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_cos_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::cos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_cos_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::cos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_cos_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::cos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_cos_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::cos(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_cos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_cos_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::cos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_cos_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::cos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_cos_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::cos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_cos_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::cos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> tan()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_tan_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tan(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_tan_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::tan(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_tan_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::tan(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_tan_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::tan(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_tan_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tan(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_tan_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::tan(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_tan()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_tan_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tan(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_tan_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::tan(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_tan_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tan(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_tan_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::tan(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> acos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_acos_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::acos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_acos_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::acos(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_acos_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::acos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_acos_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::acos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_acos_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::acos(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_acos_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::acos(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_acos()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_acos_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::acos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_acos_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::acos(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_acos_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::acos(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_acos_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::acos(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> round()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::round(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::round(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::round(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::round(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::round(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::round(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_round()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::round(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::round(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::round(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_round_ps(a, _MM_FROUND_TO_NEAREST_INT));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::round(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		template<bool returnTransposed = false>
		inline matrix<float> floor()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_floor_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::floor(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_floor_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::floor(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_floor_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::floor(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_floor_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::floor(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_floor_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::floor(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_floor_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::floor(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_floor()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_floor_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::floor(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_floor_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::floor(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_floor_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::floor(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_floor_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::floor(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// pow

		template<bool returnTransposed = false>
		inline matrix<float> pow(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> pow(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], data2[i]);
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j],
									data2[(i + 4) * matrix2ActualCols + j],
									data2[(i + 5) * matrix2ActualCols + j],
									data2[(i + 6) * matrix2ActualCols + j],
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i],
									data1[(j + 4) * matrix1ActualRows + i],
									data1[(j + 5) * matrix1ActualRows + i],
									data1[(j + 6) * matrix1ActualRows + i],
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j],
									data1[(i + 4) * matrix1ActualCols + j],
									data1[(i + 5) * matrix1ActualCols + j],
									data1[(i + 6) * matrix1ActualCols + j],
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i],
									data2[(j + 4) * matrix2ActualRows + i],
									data2[(j + 5) * matrix2ActualRows + i],
									data2[(j + 6) * matrix2ActualRows + i],
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;


						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], data2[i]);
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
								}
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_pow(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
			}
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void self_pow(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], data2[i]);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j],
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], data2[i * matrix2ActualCols + j]);
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i],
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i],
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[j * matrix2ActualRows + i]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], data2[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
		}

		// root

		template<bool returnTransposed = false>
		inline matrix<float> root(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			num = 1.0f / num;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, b));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::pow(data1[i], num);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, b));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
							}
						}
					}
				}
			}
			return result;
		}

		template<bool returnTransposed = false, bool otherTransposed, bool otherContiguous>
		inline matrix<float> root(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256d one = _mm256_set1_ps(1.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (returnTransposed)
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t size = this->_size;

							size_t finalPosSize = this->finalPosSize;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], 1.0f / data2[i]);
							}
						}
						else
						{
							size_t finalPosRows = this->finalPosRows;
							size_t finalPosCols = this->finalPosCols;

							size_t matrix1ActualRows = this->actualRows;
							size_t matrix2ActualRows = other.actualRows;

							for (size_t i = 0; i < finalPosRows; i += 8)
							{
								for (size_t j = 0; j < cols; j++)
								{
									__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
									__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

									_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
								}
							}
							for (size_t i = finalPosRows; i < rows; i++)
							{
								for (size_t j = 0; j < cols; j++)
								{
									dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[j * matrix2ActualRows + i]);
								}
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t j = 0; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
									data2[(i + 1) * matrix2ActualCols + j],
									data2[(i + 2) * matrix2ActualCols + j],
									data2[(i + 3) * matrix2ActualCols + j],
									data2[(i + 4) * matrix2ActualCols + j],
									data2[(i + 5) * matrix2ActualCols + j],
									data2[(i + 6) * matrix2ActualCols + j],
									data2[(i + 7) * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualCols = other.actualCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
									data1[(j + 1) * matrix1ActualRows + i],
									data1[(j + 2) * matrix1ActualRows + i],
									data1[(j + 3) * matrix1ActualRows + i],
									data1[(j + 4) * matrix1ActualRows + i],
									data1[(j + 5) * matrix1ActualRows + i],
									data1[(j + 6) * matrix1ActualRows + i],
									data1[(j + 7) * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					if constexpr (returnTransposed)
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
									data1[(i + 1) * matrix1ActualCols + j],
									data1[(i + 2) * matrix1ActualCols + j],
									data1[(i + 3) * matrix1ActualCols + j],
									data1[(i + 4) * matrix1ActualCols + j],
									data1[(i + 5) * matrix1ActualCols + j],
									data1[(i + 6) * matrix1ActualCols + j],
									data1[(i + 7) * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[j * rows + i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[j * matrix2ActualRows + i]);
							}
						}
					}
					else
					{
						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
									data2[(j + 1) * matrix2ActualRows + i],
									data2[(j + 2) * matrix2ActualRows + i],
									data2[(j + 3) * matrix2ActualRows + i],
									data2[(j + 4) * matrix2ActualRows + i],
									data2[(j + 5) * matrix2ActualRows + i],
									data2[(j + 6) * matrix2ActualRows + i],
									data2[(j + 7) * matrix2ActualRows + i]);
								_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					if constexpr (returnTransposed)
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;


						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[i * matrix2ActualCols + j]);
							}
						}
					}
					else
					{
						if constexpr (thisContiguous && otherContiguous)
						{
							size_t finalPosSize = this->finalPosSize;
							size_t size = this->_size;

							for (size_t i = 0; i < finalPosSize; i += 8)
							{
								__m256 a = _mm256_load_ps(&data1[i]);
								__m256 b = _mm256_load_ps(&data2[i]);

								_mm256_store_ps(&dataResult[i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
							for (size_t i = finalPosSize; i < size; i++)
							{
								dataResult[i] = std::pow(data1[i], 1.0f / data2[i]);
							}
						}
						else
						{
							size_t matrix1ActualCols = this->actualCols;
							size_t matrix2ActualCols = other.actualCols;

							size_t finalPosCols = this->finalPosCols;
							size_t finalPosRows = this->finalPosRows;

							for (size_t j = 0; j < finalPosCols; j += 8)
							{
								for (size_t i = 0; i < rows; i++)
								{
									__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
									__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

									_mm256_store_ps(&dataResult[i * cols + j], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
								}
							}
							for (size_t j = finalPosCols; j < cols; j++)
							{
								for (size_t i = 0; i < rows; i++)
								{
									dataResult[i * cols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[i * matrix2ActualCols + j]);
								}
							}
						}
					}
				}
			}
			return result;
		}
		
		inline void self_root(float num)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			num = 1.0f / num;

			__m256 b = _mm256_set1_ps(num);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, b));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], num);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_pow_ps(a, b));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::pow(data1[i], num);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, b));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], num);
						}
					}
				}
			}
		}

		template<bool otherTransposed, bool otherContiguous>
		inline void self_root(const matrix<float, otherTransposed, otherContiguous>& other)
		{
#ifdef _DEBUG
			if (other._cols != this->_cols || other._rows != this->_rows) throw std::invalid_argument("The dimensions of both matrices must be the same");
#else
#endif

			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;
			float* data2 = other._data;

			__m256 one = _mm256_set1_ps(1.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (otherTransposed)
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t size = this->_size;

						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], 1.0f / data2[i]);
						}
					}
					else
					{
						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						size_t matrix1ActualRows = this->actualRows;
						size_t matrix2ActualRows = other.actualRows;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < cols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
								__m256 b = _mm256_load_ps(&data2[j * matrix2ActualRows + i]);

								_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[j * matrix2ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					size_t matrix1ActualRows = this->actualRows;
					size_t matrix2ActualCols = other.actualCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);
							__m256 b = _mm256_setr_ps(data2[i * matrix2ActualCols + j],
								data2[(i + 1) * matrix2ActualCols + j],
								data2[(i + 2) * matrix2ActualCols + j],
								data2[(i + 3) * matrix2ActualCols + j],
								data2[(i + 4) * matrix2ActualCols + j],
								data2[(i + 5) * matrix2ActualCols + j],
								data2[(i + 6) * matrix2ActualCols + j],
								data2[(i + 7) * matrix2ActualCols + j]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::pow(data1[j * matrix1ActualRows + i], 1.0f / data2[i * matrix2ActualCols + j]);
						}
					}
				}
			}
			else
			{
				if constexpr (otherTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;
					size_t matrix2ActualRows = other.actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
							__m256 b = _mm256_setr_ps(data2[j * matrix2ActualRows + i],
								data2[(j + 1) * matrix2ActualRows + i],
								data2[(j + 2) * matrix2ActualRows + i],
								data2[(j + 3) * matrix2ActualRows + i],
								data2[(j + 4) * matrix2ActualRows + i],
								data2[(j + 5) * matrix2ActualRows + i],
								data2[(j + 6) * matrix2ActualRows + i],
								data2[(j + 7) * matrix2ActualRows + i]);
							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[j * matrix2ActualRows + i]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous && otherContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							__m256 b = _mm256_load_ps(&data2[i]);

							_mm256_store_ps(&data1[i], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							data1[i] = std::pow(data1[i], 1.0f / data2[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;
						size_t matrix2ActualCols = other.actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
								__m256 b = _mm256_load_ps(&data2[i * matrix2ActualCols + j]);

								_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_pow_ps(a, _mm256_div_ps(one, b)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								data1[i * matrix1ActualCols + j] = std::pow(data1[i * matrix1ActualCols + j], 1.0f / data2[i * matrix2ActualCols + j]);
							}
						}
					}
				}
			}
		}

		// Mean 

		inline vector<float> mean_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(rows);

			float* dataResult = result._data;

			float cols_f = static_cast<float>(cols);

			__m256 _cols = _mm256_set1_ps(cols_f);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[i], _mm256_div_ps(_sum, _cols));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[i] = sum / cols_f;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j], 
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[i], _mm256_div_ps(_sum, _cols));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(data1[i * matrix1ActualCols + j]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[i] = sum / cols_f;
				}
			}
			return result;
		}

		inline vector<float> mean_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(cols);

			float* dataResult = result._data;

			float rows_f = static_cast<float>(rows);

			__m256 _rows = _mm256_set1_ps(rows_f);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[j], _mm256_div_ps(_sum, _rows));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[j] = sum / rows_f;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[j], _mm256_div_ps(_sum, _rows));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j], 
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[j] = sum / rows_f;
				}
			}
			return result;
		}

		inline float mean_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t size = this->_size;

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();
			float sum = 0.0f;

			if constexpr (thisContiguous)
			{
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					sum += data1[i];
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j], 
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
				}
			}

			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

			
			__m128 lo128 = _mm256_castps256_ps128(_sum2, 0);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);

			sum += _mm_cvtss_f32(result128);

			return sum / static_cast<float>(size);
		}

		// Sum

		inline vector<float> sum_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(rows);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[i], _sum);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[i] = sum;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[i], _sum);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(data1[i * matrix1ActualCols + j]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[i] = sum;
				}
			}
			return result;
		}

		inline vector<float> sum_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[j], _sum);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
					dataResult[j] = sum;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[j], _sum);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
					dataResult[j] = sum;
				}
			}
			return result;
		}

		inline float sum_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t size = this->_size;

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();
			float sum = 0.0f;

			if constexpr (thisContiguous)
			{
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					sum += data1[i];
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						sum += data1[j * matrix1ActualRows + i];
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_sum = _mm256_add_ps(_sum, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_sum = _mm256_add_ps(_sum, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						sum += data1[i * matrix1ActualCols + j];
					}
				}
			}

			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);


			__m128 lo128 = _mm256_castps256_ps128(_sum2, 0);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);

			sum += _mm_cvtss_f32(result128);

			return sum;
		}

		// Std

		inline vector<float> std_rowwise(float ddof = 0.0f)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(rows);

			float* dataResult = result._data;

			float cols_f = static_cast<float>(cols);

			__m256 _cols = _mm256_set1_ps(cols_f);
			__m256 _ddof = _mm256_set1_ps(ddof);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 variance = _mm256_div_ps(_mm256_sub_ps(_sumSquare, _mm256_div_ps(_mm256_mul_ps(_sum, _sum), _cols)), _mm256_sub_ps(_cols, _ddof));
					_mm256_store_ps(&dataResult[i], _mm256_sqrt_ps(variance));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}

					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);
					//--
					_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
					_sum2 = _mm256_hadd_ps(_sum1, _sum1);

					lo128 = _mm256_castps256_ps128(_sum2);
					hi128 = _mm256_extractf128_ps(_sum2, 1);
					result128 = _mm_add_ps(lo128, hi128);
					float sumSquare = _mm_cvtss_f32(result128);

					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
					float variance = (sumSquare - (sum * sum / cols_f)) / (cols_f - ddof);
					float std = std::sqrt(variance);
					dataResult[i] = std;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j], 
							data1[(i + 7) * matrix1ActualCols + j]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 variance = _mm256_div_ps(_mm256_sub_ps(_sumSquare, _mm256_div_ps(_mm256_mul_ps(_sum, _sum), _cols)), _mm256_sub_ps(_cols, _ddof));
					_mm256_store_ps(&dataResult[i], _mm256_sqrt_ps(variance));
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}

					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);
					//--
					_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
					_sum2 = _mm256_hadd_ps(_sum1, _sum1);

					lo128 = _mm256_castps256_ps128(_sum2);
					hi128 = _mm256_extractf128_ps(_sum2, 1);
					result128 = _mm_add_ps(lo128, hi128);
					float sumSquare = _mm_cvtss_f32(result128);

					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
					float variance = (sumSquare - (sum * sum / cols_f)) / (cols_f - ddof);
					float std = std::sqrt(variance);
					dataResult[i] = std;
				}
			}
			return result;
		}

		inline vector<float> std_colwise(float ddof = 0.0f)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(cols);

			float* dataResult = result._data;

			float rows_f = static_cast<float>(rows);

			__m256 _rows = _mm256_set1_ps(rows_f);
			__m256 _ddof = _mm256_set1_ps(ddof);

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 variance = _mm256_div_ps(_mm256_sub_ps(_sumSquare, _mm256_div_ps(_mm256_mul_ps(_sum, _sum), _rows)), _mm256_sub_ps(_rows, _ddof));
					_mm256_store_ps(&dataResult[j], _mm256_sqrt_ps(variance));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);
					//--
					_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
					_sum2 = _mm256_hadd_ps(_sum1, _sum1);

					lo128 = _mm256_castps256_ps128(_sum2);
					hi128 = _mm256_extractf128_ps(_sum2, 1);
					result128 = _mm_add_ps(lo128, hi128);
					float sumSquare = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
					float variance = (sumSquare - (sum * sum / rows_f)) / (rows_f - ddof);
					float std = std::sqrt(variance);
					dataResult[j] = std;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 variance = _mm256_div_ps(_mm256_sub_ps(_sumSquare, _mm256_div_ps(_mm256_mul_ps(_sum, _sum), _rows)), _mm256_sub_ps(_rows, _ddof));
					_mm256_store_ps(&dataResult[j], _mm256_sqrt_ps(variance));
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _sum = _mm256_setzero_ps();
					__m256 _sumSquare = _mm256_setzero_ps();

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
					__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

					__m128 lo128 = _mm256_castps256_ps128(_sum2);
					__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
					__m128 result128 = _mm_add_ps(lo128, hi128);
					float sum = _mm_cvtss_f32(result128);
					//--
					_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
					_sum2 = _mm256_hadd_ps(_sum1, _sum1);

					lo128 = _mm256_castps256_ps128(_sum2);
					hi128 = _mm256_extractf128_ps(_sum2, 1);
					result128 = _mm_add_ps(lo128, hi128);
					float sumSquare = _mm_cvtss_f32(result128);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
					float variance = (sumSquare - (sum * sum / rows_f)) / (rows_f - ddof);
					float std = std::sqrt(variance);
					dataResult[j] = std;
				}
			}
			return result;
		}

		inline float std_all(float ddof = 0.0f, float* mean = nullptr)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			size_t size = this->_size;

			float size_f = static_cast<float>(size);

			float* data1 = this->_data;

			__m256 _sum = _mm256_setzero_ps();
			__m256 _sumSquare = _mm256_setzero_ps();

			float sum = 0.0;
			float sumSquare = 0.0;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					__m256 a = _mm256_load_ps(&data1[i]);

					_sum = _mm256_add_ps(_sum, a);
					_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					float data = data1[i];
					sum += data;
					sumSquare += data * data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]);

						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						sum += data;
						sumSquare += data * data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);
						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j], 
							data1[(i + 7) * matrix1ActualCols + j]);
						_sum = _mm256_add_ps(_sum, a);
						_sumSquare = _mm256_add_ps(_sumSquare, _mm256_mul_ps(a, a));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						sum += data;
						sumSquare += data * data;
					}
				}
			}

			__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
			__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

			__m128 lo128 = _mm256_castps256_ps128(_sum2);
			__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
			__m128 result128 = _mm_add_ps(lo128, hi128);
			sum += _mm_cvtss_f32(result128);
			//--
			_sum1 = _mm256_hadd_ps(_sumSquare, _sumSquare);
			_sum2 = _mm256_hadd_ps(_sum1, _sum1);

			lo128 = _mm256_castps256_ps128(_sum2);
			hi128 = _mm256_extractf128_ps(_sum2, 1);
			result128 = _mm_add_ps(lo128, hi128);
			sumSquare += _mm_cvtss_f32(result128);

			if (mean != nullptr) *mean = sum / size_f;

			float variance = (sumSquare - (sum * sum / size_f)) / (size_f - ddof);
			float std = std::sqrt(variance);
			return std;
		}

		// Min

		inline vector<float> min_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(rows);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[i], _min);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					__m128 val1 = _mm256_castps256_ps128(_min);

					__m128 val2 = _mm256_extractf128_ps(_min, 1);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_min_ps(val1, val2);

					float min = _mm_cvtss_f32(val1);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
					dataResult[i] = min;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[i], _min);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(data1[i * matrix1ActualCols + j]));
					}
					__m128 val1 = _mm256_castps256_ps128(_min);

					__m128 val2 = _mm256_extractf128_ps(_min, 1);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_min_ps(val1, val2);

					float min = _mm_cvtss_f32(val1);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
					dataResult[i] = min;
				}
			}
			return result;
		}

		inline vector<float> min_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i], 
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[j], _min);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					__m128 val1 = _mm256_castps256_ps128(_min);

					__m128 val2 = _mm256_extractf128_ps(_min, 1);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_min_ps(val1, val2);

					float min = _mm_cvtss_f32(val1);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
					dataResult[j] = min;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[j], _min);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _min = _mm256_set1_ps(FLT_MAX);

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					__m128 val1 = _mm256_castps256_ps128(_min);

					__m128 val2 = _mm256_extractf128_ps(_min, 1);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_min_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_min_ps(val1, val2);

					float min = _mm_cvtss_f32(val1);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
					dataResult[j] = min;
				}
			}
			return result;
		}

		inline float min_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 _min = _mm256_set1_ps(FLT_MAX);
			float min = FLT_MAX;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					float data = data1[i];
					if (data < min) min = data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i], 
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min) min = data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_min = _mm256_min_ps(_min, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_min = _mm256_min_ps(_min, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j], 
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min) min = data;
					}
				}
			}

			__m128 val1 = _mm256_castps256_ps128(_min);

			__m128 val2 = _mm256_extractf128_ps(_min, 1);

			val1 = _mm_min_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b1110);

			val1 = _mm_min_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b11100001);

			val1 = _mm_min_ps(val1, val2);

			float temp_min_f = _mm_cvtss_f32(val1);

			if (temp_min_f < min) min = temp_min_f;

			return min;
		}

		inline void argmin_all(size_t* row, size_t* col)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256i four = _mm256_set1_epi64x(4);

			__m128 _min = _mm_set1_ps(FLT_MAX);
			float min = FLT_MAX;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;

				size_t finalPosSize = this->finalPosSize;

				__m256i min_indices = _mm256_setr_epi64x(0, 1, 2, 4);
				size_t min_index = 0;

				__m256i indices = _mm256_setr_epi64x(0, 1, 2, 4);

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					__m128 a = _mm_load_ps(&data1[i]);

					int mask = _mm_movemask_ps(_mm_cmp_ps(a, _min, _CMP_LT_OQ));

					min_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

					_min = _mm_blend_ps(_min, a, mask);

					indices = _mm256_add_epi64(indices, four);
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					float data = data1[i];
					if (data < min)
					{
						min = data;
						min_index = i;
					}
				}

				float mins_arr[4];
				size_t indices_arr[4];

				_mm_store_ps(mins_arr, _min);
				_mm256_storeu_epi64(indices_arr, indices);

				for (size_t i = 0; i < 4; i++)
				{
					float element = mins_arr[i];
					if (element < min)
					{
						min = element;
						min_index = indices_arr[i];
					}
				}
				if constexpr (thisTransposed)
				{
					*row = min_index % rows;
					*col = min_index / rows;
				}
				else
				{
					*row = min_index / cols;
					*col = min_index % cols;
				}

			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i _i = _mm256_set1_epi64x(0, 1, 2, 3);
				__m256i _j = _mm256_setzero_si256();

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_min = _mm256_setzero_si256();
				__m256i _j_min = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m128 a = _mm_load_ps(&data1[j * matrix1ActualRows + i]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _min, _CMP_LT_OQ));

						_i_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_min), _mm256_castsi256_pd(_i), mask));

						_j_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_min), _mm256_castsi256_pd(_j), mask));

						_min = _mm_blend_ps(_min, a, mask);

						_j = _mm256_add_epi64(_j, one);
					}
					_i = _mm256_add_epi64(_i, four);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				float mins_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm_store_ps(mins_arr, _min);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					float element = mins_arr[i];
					if (element < min)
					{
						min = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i _i = _mm256_setzero_si256();
				__m256i _j = _mm256_set1_epi64x(0, 1, 2, 3);

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_min = _mm256_setzero_si256();
				__m256i _j_min = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm_load_ps(&data1[i * matrix1ActualCols + j]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _min, _CMP_LT_OQ));

						_i_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_min), _mm256_castsi256_pd(_i), mask));

						_j_min = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_min), _mm256_castsi256_pd(_j), mask));

						_min = _mm_blend_ps(_min, a, mask);

						_i = _mm256_add_epi64(_i, one);
					}
					_j = _mm256_add_epi64(_j_min, four);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				float mins_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm_store_ps(mins_arr, _min);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					float element = mins_arr[i];
					if (element < min)
					{
						min = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
		}

		inline vector<uint64_t> argmin_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<uint64_t> result(rows);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m128 _min = _mm_set1_ps(FLT_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m128 a = _mm_load_ps(&data1[j * matrix1ActualRows + i]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _min, _CMP_LT_OQ));

						min_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm_blend_ps(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], min_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					float min = FLT_MAX;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				for (size_t i = 0; i < rows; i++)
				{
					float min = FLT_MAX;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			return result;
		}

		inline vector<uint64_t> argmin_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<uint64_t> result(cols);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				for (size_t j = 0; j < cols; j++)
				{
					float min = FLT_MAX;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data < min)
						{
							min = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m128 _min = _mm_set1_ps(FLT_MAX);
					__m256i indices = _mm256_setzero_si256();
					__m256i min_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < cols; i++)
					{
						__m128 a = _mm_load_ps(&data1[i * matrix1ActualCols + j]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _min, _CMP_LT_OQ));

						min_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(min_indices), _mm256_castsi256_pd(indices), mask));

						_min = _mm_blend_ps(_min, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], min_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					float min = FLT_MAX;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data < min)
						{
							min = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			return result;
		}

		// Max

		inline vector<float> max_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(rows);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[i], _max);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					__m128 val1 = _mm256_castps256_ps128(_max);

					__m128 val2 = _mm256_extractf128_ps(_max, 1);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_max_ps(val1, val2);

					float max = _mm_cvtss_f32(val1);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
					dataResult[i] = max;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[i], _max);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(data1[i * matrix1ActualCols + j]));
					}
					__m128 val1 = _mm256_castps256_ps128(_max);

					__m128 val2 = _mm256_extractf128_ps(_max, 1);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_max_ps(val1, val2);

					float max = _mm_cvtss_f32(val1);

					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
					dataResult[i] = max;
				}
			}
			return result;
		}

		inline vector<float> max_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<float> result(cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					_mm256_store_ps(&dataResult[j], _max);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
					__m128 val1 = _mm256_castps256_ps128(_max);

					__m128 val2 = _mm256_extractf128_ps(_max, 1);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_max_ps(val1, val2);

					float max = _mm_cvtss_f32(val1);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
					dataResult[j] = max;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
					_mm256_store_ps(&dataResult[j], _max);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					__m256 _max = _mm256_set1_ps(FLT_MIN);

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					__m128 val1 = _mm256_castps256_ps128(_max);

					__m128 val2 = _mm256_extractf128_ps(_max, 1);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b1110);

					val1 = _mm_max_ps(val1, val2);

					val2 = _mm_permute_ps(val1, 0b11100001);

					val1 = _mm_max_ps(val1, val2);

					float max = _mm_cvtss_f32(val1);

					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
					dataResult[j] = max;
				}
			}
			return result;
		}

		inline float max_all()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 _max = _mm256_set1_ps(FLT_MIN);
			float max = FLT_MIN;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;
				size_t finalPosSize = this->finalPosSize;

				for (size_t i = 0; i < finalPosSize; i += 8)
				{
					_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[i]));
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					float data = data1[i];
					if (data > max) max = data;
				}
			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;
				size_t finalPosCols = this->finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[j * matrix1ActualRows + i]));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]));
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max) max = data;
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;
				size_t finalPosRows = this->finalPosRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						_max = _mm256_max_ps(_max, _mm256_load_ps(&data1[i * matrix1ActualCols + j]));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						_max = _mm256_max_ps(_max, _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]));
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max) max = data;
					}
				}
			}

			__m128 val1 = _mm256_castps256_ps128(_max);

			__m128 val2 = _mm256_extractf128_ps(_max, 1);

			val1 = _mm_max_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b1110);

			val1 = _mm_max_ps(val1, val2);

			val2 = _mm_permute_ps(val1, 0b11100001);

			val1 = _mm_max_ps(val1, val2);

			float temp_max_f = _mm_cvtss_f32(val1);

			if (temp_max_f > max) max = temp_max_f;

			return max;
		}

		inline void argmax_all(size_t* row, size_t* col)
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256i four = _mm256_set1_epi64x(4);

			__m128 _max = _mm_set1_ps(FLT_MIN);
			float max = FLT_MIN;

			if constexpr (thisContiguous)
			{
				size_t size = this->_size;

				size_t finalPosSize = this->finalPosSize;

				__m256i max_indices = _mm256_setr_epi64x(0, 1, 2, 4);
				size_t max_index = 0;

				__m256i indices = _mm256_setr_epi64x(0, 1, 2, 4);

				for (size_t i = 0; i < finalPosSize; i += 4)
				{
					__m128 a = _mm_load_ps(&data1[i]);

					int mask = _mm_movemask_ps(_mm_cmp_ps(a, _max, _CMP_GT_OQ));

					max_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

					_max = _mm_blend_ps(_max, a, mask);

					indices = _mm256_add_epi64(indices, four);
				}
				for (size_t i = finalPosSize; i < size; i++)
				{
					float data = data1[i];
					if (max < data)
					{
						max = data;
						max_index = i;
					}
				}

				float maxs_arr[4];
				size_t indices_arr[4];

				_mm_store_ps(maxs_arr, _max);
				_mm256_storeu_epi64(indices_arr, indices);

				for (size_t i = 0; i < 4; i++)
				{
					float element = maxs_arr[i];
					if (element < max)
					{
						max = element;
						max_index = indices_arr[i];
					}
				}
				if constexpr (thisTransposed)
				{
					*row = max_index % rows;
					*col = max_index / rows;
				}
				else
				{
					*row = max_index / cols;
					*col = max_index % cols;
				}

			}
			else if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i _i = _mm256_set1_epi64x(0, 1, 2, 3);
				__m256i _j = _mm256_setzero_si256();

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_max = _mm256_setzero_si256();
				__m256i _j_max = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m128 a = _mm_load_ps(&data1[j * matrix1ActualRows + i]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _max, _CMP_GT_OQ));

						_i_max = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_max), _mm256_castsi256_pd(_i), mask));

						_j_max = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_max), _mm256_castsi256_pd(_j), mask));

						_max = _mm_blend_ps(_max, a, mask);

						_j = _mm256_add_epi64(_j, one);
					}
					_i = _mm256_add_epi64(_i, four);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				float maxs_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm_store_ps(maxs_arr, _max);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					float element = maxs_arr[i];
					if (element < max)
					{
						max = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i _i = _mm256_setzero_si256();
				__m256i _j = _mm256_set1_epi64x(0, 1, 2, 3);

				__m256i one = _mm256_set1_epi64x(1);

				__m256i _i_max = _mm256_setzero_si256();
				__m256i _j_max = _mm256_setzero_si256();

				size_t row_index;
				size_t col_index;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm_load_ps(&data1[i * matrix1ActualCols + j]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _max, _CMP_GT_OQ));

						_i_max = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_i_max), _mm256_castsi256_pd(_i), mask));

						_j_max = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(_j_max), _mm256_castsi256_pd(_j), mask));

						_max = _mm_blend_ps(_max, a, mask);

						_i = _mm256_add_epi64(_i, one);
					}
					_j = _mm256_add_epi64(_j_max, four);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							row_index = i;
							col_index = j;
						}
					}
				}

				float maxs_arr[4];
				size_t i_arr[4];
				size_t j_arr[4];

				_mm_store_ps(maxs_arr, _max);
				_mm256_storeu_epi64(i_arr, _i);
				_mm256_storeu_epi64(j_arr, _j);

				for (size_t i = 0; i < 4; i++)
				{
					float element = maxs_arr[i];
					if (element < max)
					{
						max = element;
						row_index = i_arr[i];
						col_index = j_arr[i];
					}
				}
				*row = row_index;
				*col = col_index;
			}
		}

		inline vector<uint64_t> argmax_rowwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<uint64_t> result(rows);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				size_t finalPosRows = this->finalPosRows;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					__m128 _max = _mm_set1_ps(FLT_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t j = 0; j < cols; j++)
					{
						__m128 a = _mm_load_ps(&data1[j * matrix1ActualRows + i]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _max, _CMP_GT_OQ));

						max_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm_blend_ps(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[i], max_indices);
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					float max = FLT_MIN;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				for (size_t i = 0; i < rows; i++)
				{
					float max = FLT_MIN;
					size_t index;
					for (size_t j = 0; j < cols; j++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							index = j;
						}
					}
					dataResult[i] = index;
				}
			}
			return result;
		}

		inline vector<uint64_t> argmax_colwise()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			vector<uint64_t> result(cols);

			uint64_t* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				size_t matrix1ActualRows = this->actualRows;

				for (size_t j = 0; j < cols; j++)
				{
					float max = FLT_MIN;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[j * matrix1ActualRows + i];
						if (data > max)
						{
							max = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			else
			{
				size_t matrix1ActualCols = this->actualCols;

				size_t finalPosCols = this->finalPosCols;

				__m256i one = _mm256_set1_epi64x(1);

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					__m128 _max = _mm_set1_ps(FLT_MIN);
					__m256i indices = _mm256_setzero_si256();
					__m256i max_indices = _mm256_setzero_si256();
					for (size_t i = 0; i < cols; i++)
					{
						__m128 a = _mm_load_ps(&data1[i * matrix1ActualCols + j]);

						int mask = _mm_movemask_ps(_mm_cmp_ps(a, _max, _CMP_GT_OQ));

						max_indices = _mm256_castpd_si256(_mm256_blend_pd(_mm256_castsi256_pd(max_indices), _mm256_castsi256_pd(indices), mask));

						_max = _mm_blend_ps(_max, a, mask);

						indices = _mm256_add_epi64(indices, one);
					}
					_mm256_storeu_epi64(&dataResult[j], max_indices);
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					float max = FLT_MIN;
					size_t index;
					for (size_t i = 0; i < rows; i++)
					{
						float data = data1[i * matrix1ActualCols + j];
						if (data > max)
						{
							max = data;
							index = i;
						}
					}
					dataResult[j] = index;
				}
			}
			return result;
		}

		// Activation functions

		// ReLU

		template<bool returnTransposed = false>
		inline matrix<float> relu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 zero = _mm256_setzero_ps();

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_max_ps(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.0f, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_max_ps(zero, a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::max(0.0f, data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i], 
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i], 
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_max_ps(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::max(0.0f, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j], 
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_max_ps(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::max(0.0f, data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_max_ps(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.0f, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_max_ps(zero, a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::max(0.0f, data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_relu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 zero = _mm256_setzero_ps();

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_max_ps(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.0f, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_max_ps(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::max(0.0f, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_max_ps(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.0f, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_max_ps(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::max(0.0f, data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// LReLU

		template<bool returnTransposed = false>
		inline matrix<float> lrelu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 zero = _mm256_set1_ps(0.01f);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_max_ps(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.01f, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_max_ps(zero, a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::max(0.01f, data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_max_ps(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::max(0.01f, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_max_ps(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::max(0.01f, data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_max_ps(zero, a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::max(0.01f, data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_max_ps(zero, a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::max(0.01f, data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_lrelu()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 zero = _mm256_set1_ps(0.01f);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_max_ps(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.01f, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_max_ps(zero, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::max(0.01f, data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_max_ps(zero, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::max(0.01f, data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_max_ps(zero, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::max(0.01f, data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// Sigmoid

		template<bool returnTransposed = false>
		inline matrix<float> sigmoid()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 one = _mm256_set1_ps(1.0f);

			__m256 mask = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = 1.0f / (1.0f + std::exp(-data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = 1.0f / (1.0f + std::exp(-data1[i]));
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i], 
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i], 
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = 1.0f / (1.0f + std::exp(-data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j], 
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = 1.0f / (1.0f + std::exp(-data1[i * matrix1ActualCols + j]));
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = 1.0f / (1.0f + std::exp(-data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = 1.0f / (1.0f + std::exp(-data1[i * matrix1ActualCols + j]));
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_sigmoid()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 one = _mm256_set1_ps(1.0f);

			__m256 mask = _mm256_set1_ps(-0.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = 1.0f / (1.0f + std::exp(-data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = 1.0f / (1.0f + std::exp(-data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = 1.0f / (1.0f + std::exp(-data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_div_ps(one, _mm256_add_ps(_mm256_exp_ps(_mm256_xor_ps(a, mask)), one)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = 1.0f / (1.0f + std::exp(-data1[i * matrix1ActualCols + j]));
						}
					}
				}
			}
		}

		// Softplus

		template<bool returnTransposed = false>
		inline matrix<float> softplus()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			__m256 one = _mm256_set1_ps(1.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(1.0f + std::exp(data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::log(1.0f + std::exp(data1[i]));
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i], 
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::log(1.0f + std::exp(data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j], 
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::log(1.0f + std::exp(data1[i * matrix1ActualCols + j]));
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::log(1.0f + std::exp(data1[i]));
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::log(1.0f + std::exp(data1[i * matrix1ActualCols + j]));
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_softplus()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			__m256 one = _mm256_set1_ps(1.0f);

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(1.0f + std::exp(data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = finalPosCols; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::log(1.0f + std::exp(data1[j * matrix1ActualRows + i]));
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::log(1.0f + std::exp(data1[i]));
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_log_ps(_mm256_add_ps(one, _mm256_exp_ps(a))));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::log(1.0f + std::exp(data1[i * matrix1ActualCols + j]));
						}
					}
				}
			}
		}

		// Tanh

		template<bool returnTransposed = false>
		inline matrix<float> tanh()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<float> result(rows, cols);

			float* dataResult = result._data;

			if constexpr (thisTransposed)
			{
				if constexpr (returnTransposed)
				{
					if constexpr (thisContiguous)
					{
						size_t finalPosSize = this->finalPosSize;
						size_t size = this->_size;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);

							_mm256_store_ps(&dataResult[i], _mm256_tanh_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tanh(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualRows = this->actualRows;

						size_t finalPosRows = this->finalPosRows;
						size_t finalPosCols = this->finalPosCols;

						for (size_t i = 0; i < finalPosRows; i += 8)
						{
							for (size_t j = 0; j < finalPosCols; j++)
							{
								__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

								_mm256_store_ps(&dataResult[j * rows + i], _mm256_tanh_ps(a));
							}
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							for (size_t j = 0; j < cols; j++)
							{
								dataResult[j * rows + i] = std::tanh(data1[j * matrix1ActualRows + i]);
							}
						}
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i],
								data1[(j + 4) * matrix1ActualRows + i],
								data1[(j + 5) * matrix1ActualRows + i],
								data1[(j + 6) * matrix1ActualRows + i],
								data1[(j + 7) * matrix1ActualRows + i]);
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_tanh_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < cols; i++)
						{
							dataResult[i * cols + j] = std::tanh(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (returnTransposed)
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j],
								data1[(i + 4) * matrix1ActualCols + j],
								data1[(i + 5) * matrix1ActualCols + j],
								data1[(i + 6) * matrix1ActualCols + j],
								data1[(i + 7) * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_tanh_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; i < cols; j++)
						{
							dataResult[j * rows + i] = std::tanh(data1[i * matrix1ActualCols + j]);
						}
					}
				}
				else
				{
					if constexpr (thisContiguous)
					{
						size_t size = this->_size;
						size_t finalPosSize = this->finalPosSize;

						for (size_t i = 0; i < finalPosSize; i += 8)
						{
							__m256 a = _mm256_load_ps(&data1[i]);
							_mm256_store_ps(&dataResult[i], _mm256_tanh_ps(a));
						}
						for (size_t i = finalPosSize; i < size; i++)
						{
							dataResult[i] = std::tanh(data1[i]);
						}
					}
					else
					{
						size_t matrix1ActualCols = this->actualCols;

						size_t finalPosCols = this->finalPosCols;
						size_t finalPosRows = this->finalPosRows;

						for (size_t j = 0; j < finalPosCols; j += 8)
						{
							for (size_t i = 0; i < rows; i++)
							{
								__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

								_mm256_store_ps(&dataResult[i * cols + j], _mm256_tanh_ps(a));
							}
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							for (size_t i = 0; i < rows; i++)
							{
								dataResult[i * cols + j] = std::tanh(data1[i * matrix1ActualCols + j]);
							}
						}
					}
				}
			}
			return result;
		}

		inline void self_tanh()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			if constexpr (thisTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = this->finalPosSize;
					size_t size = this->_size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&data1[i], _mm256_tanh_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tanh(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualRows = this->actualRows;

					size_t finalPosRows = this->finalPosRows;
					size_t finalPosCols = this->finalPosCols;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < finalPosCols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&data1[j * matrix1ActualRows + i], _mm256_tanh_ps(a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							data1[j * matrix1ActualRows + i] = std::tanh(data1[j * matrix1ActualRows + i]);
						}
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t size = this->_size;
					size_t finalPosSize = this->finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);
						_mm256_store_ps(&data1[i], _mm256_tanh_ps(a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						data1[i] = std::tanh(data1[i]);
					}
				}
				else
				{
					size_t matrix1ActualCols = this->actualCols;

					size_t finalPosCols = this->finalPosCols;
					size_t finalPosRows = this->finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&data1[i * matrix1ActualCols + j], _mm256_tanh_ps(a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							data1[i * matrix1ActualCols + j] = std::tanh(data1[i * matrix1ActualCols + j]);
						}
					}
				}
			}
		}

		// Cast
		template<typename T>
		inline matrix<T> cast()
		{
			size_t rows = this->_rows;
			size_t cols = this->_cols;

			float* data1 = this->_data;

			matrix<T> result(rows, cols);

			T* dataResult = result._data;

			if constexpr (std::is_same<T, int>::value)
			{
				if constexpr (thisTransposed)
				{
					size_t actualRows = this->actualRows;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<int>(data1[j * actualRows + i]);
						}
					}
				}
				else
				{
					size_t actualCols = this->actualCols;
					size_t finalPosCols = this->finalPosCols;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							_mm256_storeu_epi32(&dataResult[i * cols + j], _mm256_cvtps_epi32(_mm256_load_ps(&data1[i * actualCols + j])));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = static_cast<int>(data1[i * actualCols + j]);
						}
					}
				}
			}
			else if constexpr (std::is_same<T, double>::value)
			{
				if constexpr (thisTransposed)
				{
					size_t actualRows = this->actualRows;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<double>(data1[j * actualRows + i]);
						}
					}
				}
				else
				{
					size_t actualCols = this->actualCols;
					size_t finalPosCols = (cols / 4) * 4;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_cvtps_pd(_mm_load_ps(&data1[i * actualCols + j])));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = static_cast<double>(data1[i * actualCols + j]);
						}
					}
				}
			}
			else if constexpr (std::is_same<T, uint8_t>::value)
			{
				if constexpr (thisTransposed)
				{
					size_t actualRows = this->actualRows;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = data1[j * actualRows + i] ? True : False;
						}
					}
				}
				else
				{
					size_t actualCols = this->actualCols;
					size_t finalPosCols = this->finalPosCols;

					__m256 b = _mm256_setzero_ps();

					__m256i indices = _mm256_setr_epi32(0, 7, 2, 3, 4, 5, 6, 1);

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * actualCols + j]);

							__m256i mask = _mm256_castps_si256(_mm256_cmp_ps(a, b, _CMP_NEQ_OQ));
							__m256i mask1 = _mm256_packs_epi32(mask, mask);
							__m256i mask2 = _mm256_packs_epi16(mask1, mask1);

							mask2 = _mm256_permutevar8x32_epi32(mask2, indices);

							_mm_store_sd(reinterpret_cast<double*>(&dataResult[i * cols + j]), _mm_castsi128_pd(_mm256_castsi256_si128(mask2)));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] ? True : False;
						}
					}
				}
			}
			else
			{
				if constexpr (thisTransposed)
				{
					size_t actualRows = this->actualRows;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<T>(data1[j * actualRows + i]);
						}
					}
				}
				else
				{
					size_t actualCols = this->actualCols;
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[i * cols + j] = static_cast<T>(data1[i * actualCols + j]);
						}
					}
				}
				
			}
			return result;
		}

	private:
		float* _data;
		float* dataToDelete;
		size_t _rows, _cols, _size;
		size_t actualRows, actualCols;
		size_t finalPosRows, finalPosCols, finalPosSize;
	};

	// Where

	// Double

	inline vector<double> where(vector<uint8_t>& vector1, vector<double>& vector2, vector<double>& vector3)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size || vector2._size != vector3._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint8_t* data1 = vector1._data;
		double* data2 = vector2._data;
		double* data3 = vector3._data;

		vector<double> result(size);

		double* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d mask = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))));

			_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_mm256_load_pd(&data3[i]), _mm256_load_pd(&data2[i]), mask));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : data3[i];
		}
		return result;
	}

	inline vector<double> where(vector<uint8_t>& vector1, double num1, double num2)
	{
		size_t size = vector1._size;

		uint8_t* data1 = vector1._data;

		__m256d _num1 = _mm256_set1_pd(num1);
		__m256d _num2 = _mm256_set1_pd(num2);

		size_t finalPos = (size / 4) * 4;

		vector<double> result(size);

		double* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_num2, _num1, 
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num1 : num2;
		}
		return result;
	}

	inline vector<double> where(vector<uint8_t>& vector1, vector<double>& vector2, double num)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		double* data2 = vector2._data;

		__m256d b = _mm256_set1_pd(num);

		vector<double> result(size);

		double* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_load_pd(&data2[i]);
			_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(b, a,
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : num;
		}
		return result;
	}

	inline vector<double> where(vector<uint8_t>& vector1, double num, vector<double>& vector2)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		double* data2 = vector2._data;

		__m256d b = _mm256_set1_pd(num);

		vector<double> result(size);

		double* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_load_pd(&data2[i]);
			_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(a, b,
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num : data2[i];
		}
		return result;
	}

	template<bool returnTransposed = false, bool matrx1Transposed, bool matrix1Contiguous>
	inline matrix<double> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>& matrix1, double num1, double num2)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		__m256d _num1 = _mm256_set1_pd(num1);
		__m256d _num2 = _mm256_set1_pd(num2);

		uint8_t* data1 = matrix1._data;

		matrix<double> result(rows, cols);

		double* dataResult = result._data;

		if constexpr (matrx1Transposed)
		{
			size_t actualRows = matrix1.actualRows;

			if constexpr (returnTransposed)
			{
				if constexpr (matrix1Contiguous)
				{
					size_t size = matrix1._size;
					size_t finalPosSize = matrix1.finalPosSize;
					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))));

						_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_num2, _num1, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] ? num1 : num2;
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; i++)
						{
							__m256d a = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[j * actualRows + i])))));
							_mm256_store_pd(&dataResult[j * rows + i], _mm256_blendv_pd(_num2, _num1, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; i++)
						{
							dataResult[j * rows + i] = data1[j * actualRows + i] ? num1 : num2;
						}
					}
				}
			}
			else
			{
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; i++)
					{
						dataResult[i * cols + j] = data1[j * actualRows + i] ? num1 : num2;
					}
				}
			}
		}
		else
		{
			size_t actualCols = matrix1.actualCols;

			if constexpr (returnTransposed)
			{
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; i++)
					{
						dataResult[j * rows + i] = data1[i * actualCols + j] ? num1 : num2;
					}
				}
			}
			else
			{
				if constexpr (matrix1Contiguous)
				{
					size_t size = matrix1._size;
					size_t finalPosSize = matrix1.finalPosSize;
					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))));

						_mm256_store_pd(&dataResult[i], _mm256_blendv_pd(_num2, _num1, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] ? num1 : num2;
					}
				}
				else
				{
					size_t actualCols = matrix1.actualCols;
					size_t finalPosCols = matrix1.finalPosCols;
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i * actualCols + j])))));
							_mm256_store_pd(&dataResult[i * cols + j], _mm256_blendv_pd(_num2, _num1, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] ? num1 : num2;
						}
					}
				}
			}
		}
		return result;
	}

	// Float

	inline vector<float> where(vector<uint8_t>& vector1, vector<float>& vector2, vector<float>& vector3)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size || vector2._size != vector3._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint8_t* data1 = vector1._data;
		float* data2 = vector2._data;
		float* data3 = vector3._data;

		vector<float> result(size);

		float* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 mask = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))));

			_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(_mm256_load_ps(&data3[i]), _mm256_load_ps(&data2[i]), mask));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : data3[i];
		}
		return result;
	}

	inline vector<float> where(vector<uint8_t>& vector1, float num1, float num2)
	{
		size_t size = vector1._size;

		uint8_t* data1 = vector1._data;

		__m256 _num1 = _mm256_set1_ps(num1);
		__m256 _num2 = _mm256_set1_ps(num2);

		size_t finalPos = (size / 8) * 8;

		vector<float> result(size);

		float* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(_num2, _num1,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num1 : num2;
		}
		return result;
	}

	inline vector<float> where(vector<uint8_t>& vector1, vector<float>& vector2, float num)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		float* data2 = vector2._data;

		__m256 b = _mm256_set1_ps(num);

		vector<float> result(size);

		float* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_load_ps(&data2[i]);
			_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(b, a,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : num;
		}
		return result;
	}

	inline vector<float> where(vector<uint8_t>& vector1, float num, vector<float>& vector2)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		float* data2 = vector2._data;

		__m256 b = _mm256_set1_ps(num);

		vector<float> result(size);

		float* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_load_ps(&data2[i]);
			_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(a, b,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num : data2[i];
		}
		return result;
	}

	template<bool returnTransposed = false, bool matrx1Transposed, bool matrix1Contiguous>
	inline matrix<float> where(matrix<uint8_t, matrx1Transposed, matrix1Contiguous>& matrix1, float num1, float num2)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		__m256 _num1 = _mm256_set1_ps(num1);
		__m256 _num2 = _mm256_set1_ps(num2);

		uint8_t* data1 = matrix1._data;

		matrix<float> result(rows, cols);

		float* dataResult = result._data;

		if constexpr (matrx1Transposed)
		{
			size_t actualRows = matrix1.actualRows;

			if constexpr (returnTransposed)
			{
				if constexpr (matrix1Contiguous)
				{
					size_t size = matrix1._size;
					size_t finalPosSize = matrix1.finalPosSize;
					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))));

						_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(_num2, _num1, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] ? num1 : num2;
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; i++)
						{
							__m256 a = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[j * actualRows + i])))));
							_mm256_store_ps(&dataResult[j * rows + i], _mm256_blendv_ps(_num2, _num1, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; i++)
						{
							dataResult[j * rows + i] = data1[j * actualRows + i] ? num1 : num2;
						}
					}
				}
			}
			else
			{
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; i++)
					{
						dataResult[i * cols + j] = data1[j * actualRows + i] ? num1 : num2;
					}
				}
			}
		}
		else
		{
			size_t actualCols = matrix1.actualCols;

			if constexpr (returnTransposed)
			{
				for (size_t i = 0; i < rows; i++)
				{
					for (size_t j = 0; j < cols; i++)
					{
						dataResult[j * rows + i] = data1[i * actualCols + j] ? num1 : num2;
					}
				}
			}
			else
			{
				if constexpr (matrix1Contiguous)
				{
					size_t size = matrix1._size;
					size_t finalPosSize = matrix1.finalPosSize;
					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))));

						_mm256_store_ps(&dataResult[i], _mm256_blendv_ps(_num2, _num1, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] ? num1 : num2;
					}
				}
				else
				{
					size_t actualCols = matrix1.actualCols;
					size_t finalPosCols = matrix1.finalPosCols;
					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i * actualCols + j])))));
							_mm256_store_ps(&dataResult[i * cols + j], _mm256_blendv_ps(_num2, _num1, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[i * actualCols + j] ? num1 : num2;
						}
					}
				}
			}
		}
		return result;
	}

	// Int

	inline vector<int> where(vector<uint8_t>& vector1, vector<int>& vector2, vector<int>& vector3)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size || vector2._size != vector3._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint8_t* data1 = vector1._data;
		int* data2 = vector2._data;
		int* data3 = vector3._data;

		vector<int> result(size);

		int* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 mask = _mm256_castsi256_ps(_mm256_cvtepi8_epi32(_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i])))));

			_mm256_storeu_epi32(&dataResult[i], _mm256_castps_si256(_mm256_blendv_ps(_mm256_castsi256_ps(_mm256_loadu_epi32(&data3[i])), _mm256_castsi256_ps(_mm256_loadu_epi32(&data2[i])), mask)));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : data3[i];
		}
		return result;
	}

	inline vector<int> where(vector<uint8_t>& vector1, int num1, int num2)

	{
		size_t size = vector1._size;

		uint8_t* data1 = vector1._data;

		__m256 _num1 = _mm256_castsi256_ps(_mm256_set1_epi32(num1));
		__m256 _num2 = _mm256_castsi256_ps(_mm256_set1_epi32(num2));

		size_t finalPos = (size / 8) * 8;

		vector<int> result(size);

		int* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			_mm256_storeu_epi32(&dataResult[i], _mm256_castps_si256(_mm256_blendv_ps(_num2, _num1,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num1 : num2;
		}
		return result;
	}

	inline vector<int> where(vector<uint8_t>& vector1, vector<int>& vector2, int num)

	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		int* data2 = vector2._data;

		__m256 b = _mm256_castsi256_ps(_mm256_set1_epi32(num));

		vector<int> result(size);

		int* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_castsi256_ps(_mm256_loadu_epi32(&data2[i]));
			_mm256_storeu_epi32(&dataResult[i], _mm256_castps_si256(_mm256_blendv_ps(b, a,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : num;
		}
		return result;
	}

	inline vector<int> where(vector<uint8_t>& vector1, int num, vector<int>& vector2)

	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		int* data2 = vector2._data;

		__m256 b = _mm256_castsi256_ps(_mm256_set1_epi32(num));

		vector<int> result(size);

		int* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_castsi256_ps(_mm256_loadu_epi32(&data2[i]));
			_mm256_storeu_epi32(&dataResult[i], _mm256_castps_si256(_mm256_blendv_ps(a, b,
				_mm256_castsi256_ps(_mm256_cvtepi8_epi32(
					_mm_castpd_si128(_mm_load_sd(reinterpret_cast<double*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num : data2[i];
		}
		return result;
	}

	// uint64_t

	inline vector<uint64_t> where(vector<uint8_t>& vector1, vector<uint64_t>& vector2, vector<uint64_t>& vector3)

	{
#ifdef _DEBUG
		if (vector1._size != vector2._size || vector2._size != vector3._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint8_t* data1 = vector1._data;
		uint64_t* data2 = vector2._data;
		uint64_t* data3 = vector3._data;

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d mask = _mm256_castsi256_pd(_mm256_cvtepi8_epi64(_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i])))));

			_mm256_storeu_epi64(&dataResult[i], _mm256_castpd_si256(_mm256_blendv_pd(_mm256_castsi256_pd(_mm256_loadu_epi64(&data3[i])), _mm256_castsi256_pd(_mm256_loadu_epi64(&data2[i])), mask)));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : data3[i];
		}
		return result;
	}

	inline vector<uint64_t> where(vector<uint8_t>& vector1, uint64_t num1, uint64_t num2)

	{
		size_t size = vector1._size;

		uint8_t* data1 = vector1._data;

		__m256d _num1 = _mm256_castsi256_pd(_mm256_set1_epi64x(num1));
		__m256d _num2 = _mm256_castsi256_pd(_mm256_set1_epi64x(num2));

		size_t finalPos = (size / 4) * 4;

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			_mm256_storeu_epi64(&dataResult[i], _mm256_castpd_si256(_mm256_blendv_pd(_num2, _num1,
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num1 : num2;
		}
		return result;
	}

	inline vector<uint64_t> where(vector<uint8_t>& vector1, vector<uint64_t>& vector2, uint64_t num)

	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		uint64_t* data2 = vector2._data;

		__m256d b = _mm256_castsi256_pd(_mm256_set1_epi64x(num));

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_castsi256_pd(_mm256_loadu_epi64(&data2[i]));
			_mm256_storeu_epi64(&dataResult[i], _mm256_castpd_si256(_mm256_blendv_pd(b, a,
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? data2[i] : num;
		}
		return result;
	}

	inline vector<uint64_t> where(vector<uint8_t>& vector1, uint64_t num, vector<uint64_t>& vector2)


	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector2.finalPos;

		uint8_t* data1 = vector1._data;

		uint64_t* data2 = vector2._data;

		__m256d b = _mm256_castsi256_pd(_mm256_set1_epi64x(num));

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_castsi256_pd(_mm256_loadu_epi64(&data2[i]));
			_mm256_storeu_epi64(&dataResult[i], _mm256_castpd_si256(_mm256_blendv_pd(a, b,
				_mm256_castsi256_pd(_mm256_cvtepi8_epi64(
					_mm_castps_si128(_mm_load_ss(reinterpret_cast<float*>(&data1[i]))))))));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = data1[i] ? num : data2[i];
		}
		return result;
	}

	//--

	inline vector<uint64_t> where(vector<uint8_t>& vector1)
	{
		size_t sizeVector1 = vector1._size;

		uint8_t* data1 = vector1._data;

		size_t sizeResult = vector1.count();
		
		vector<uint64_t> result(sizeResult);

		uint64_t* dataResult = result._data;

		for (size_t iVector1{ 0 }, iResult{ 0 }; iVector1 < sizeVector1; iVector1++)
		{
			if (data1[iVector1])
			{
				dataResult[iResult] = iVector1;
				iResult++;
			}
		}
		return result;
	}

	// Clip

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<double> clip(matrix<double, thisTransposed, thisContiguous>& matrix1, double min, double max)

	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		double* data1 = matrix1._data;

		matrix<double> result(rows, cols);

		double* dataResult = result._data;

		__m256d _min = _mm256_set1_pd(min);
		__m256d _max = _mm256_set1_pd(max);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = std::min(std::max(data1[i], min), max);
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d clip = _mm256_min_pd(_mm256_max_pd(a, _min), _max);

							__m128d val1 = _mm256_extractf128_pd(clip, 1);
							__m128d val2 = _mm256_castpd256_pd128(clip);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = std::min(std::max(data1[j * matrix1ActualRows + i], min), max);
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						_mm256_store_pd(&dataResult[i * cols + j], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						__m256d clip = _mm256_min_pd(_mm256_max_pd(a, _min), _max);

						__m128d val1 = _mm256_extractf128_pd(clip, 1);
						__m128d val2 = _mm256_castpd256_pd128(clip);

						_mm_store_sd(&dataResult[i * cols + j], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

						_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						dataResult[i * cols + j] = std::min(std::max(data1[j * matrix1ActualRows + i], min), max);
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_mm256_store_pd(&dataResult[j * rows + i], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d clip = _mm256_min_pd(_mm256_max_pd(a, _min), _max);

						__m128d val1 = _mm256_extractf128_pd(clip, 1);
						__m128d val2 = _mm256_castpd256_pd128(clip);

						_mm_store_sd(&dataResult[j * rows + i], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

						_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						dataResult[j * rows + i] = std::min(std::max(data1[i * matrix1ActualCols + j], min), max);
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = std::min(std::max(data1[i], min), max);
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_min_pd(_mm256_max_pd(a, _min), _max));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d clip = _mm256_min_pd(_mm256_max_pd(a, _min), _max);

							__m128d val1 = _mm256_extractf128_pd(clip, 1);
							__m128d val2 = _mm256_castpd256_pd128(clip);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = std::min(std::max(data1[i * matrix1ActualCols + j], min), max);
						}
					}
				}
			}
		}
		return result;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<float> clip(matrix<float, thisTransposed, thisContiguous>& matrix1, float min, float max)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		float* data1 = matrix1._data;

		matrix<float> result(rows, cols);

		float* dataResult = result._data;

		__m256 _min = _mm256_set1_ps(min);
		__m256 _max = _mm256_set1_ps(max);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = std::min(std::max(data1[i], min), max);
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = std::min(std::max(data1[j * matrix1ActualRows + i], min), max);
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]);

						_mm256_store_ps(&dataResult[i * cols + j], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						dataResult[i * cols + j] = std::min(std::max(data1[j * matrix1ActualRows + i], min), max);
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]);

						_mm256_store_ps(&dataResult[j * rows + i], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						dataResult[j * rows + i] = std::min(std::max(data1[i * matrix1ActualCols + j], min), max);
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = std::min(std::max(data1[i], min), max);
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_min_ps(_mm256_max_ps(a, _min), _max));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = std::min(std::max(data1[i * matrix1ActualCols + j], min), max);
						}
					}
				}
			}
		}
		return result;
	}

	// Dot

	inline double dot(vector<double>& vector1, vector<double>& vector2)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		double* data1 = vector1._data;
		double* data2 = vector2._data;

		vector<double> result(size);

		double* dataResult = result._data;

		double dotProduct = 0;

		__m256d _dotProduct = _mm256_setzero_pd();

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_load_pd(&data1[i]);
			__m256d b = _mm256_load_pd(&data2[i]);
			
			_dotProduct = _mm256_fmadd_pd(a, b, _dotProduct);
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dotProduct += data1[i] * data2[i];
		}

		__m128d vlow = _mm256_castpd256_pd128(_dotProduct);
		__m128d vhigh = _mm256_extractf128_pd(_dotProduct, 1);
		vlow = _mm_add_pd(vlow, vhigh);

		__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
		dotProduct += _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

		return dotProduct;
	}

	template<bool returnTransposed = false, bool matrix1Transposed, bool matrix1Contiguous,
			bool matrix2Transposed, bool matrix2Contiguous>
	inline matrix<double> dot(matrix<double, matrix1Transposed, matrix1Contiguous>& matrix1, matrix<double, matrix2Transposed, matrix2Contiguous>& matrix2)
	{
#ifdef _DEBUG
		if (matrix1._cols != matrix2._rows) throw std::invalid_argument("Wrong dimensions");
#else
#endif

		size_t matrix1Rows = matrix1._rows;
		size_t matrix1Cols = matrix1._cols;

		size_t matrix2Rows = matrix2._rows;
		size_t matrix2Cols = matrix2._cols;

		double* data1 = matrix1._data;
		double* data2 = matrix1._data;

		matrix<double> result(matrix1Rows, matrix2Cols);

		double* dataResult = result._data;

		if constexpr (matrix1Transposed)
		{
			if constexpr (matrix2Transposed)
			{
				size_t matrix1ActualRows = matrix1.actualRows;
				size_t matrix2ActualRows = matrix2.actualRows;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[k * matrix1ActualRows + i]), 
									_mm256_set1_pd(data2[j * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_pd(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[k * matrix1ActualRows + i], 
									data1[(k + 1) * matrix1ActualRows + i], 
									data1[(k + 2) * matrix1ActualRows + i], 
									data1[(k + 3) * matrix1ActualRows + i]), 
									_mm256_load_pd(&data2[j * matrix2ActualRows + k]), 
									_sum);
							}

							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (int k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[j * matrix2ActualRows + k];
							}

							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 4) 
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_set1_pd(data1[k * matrix1ActualRows + i]), 
									_mm256_setr_pd(data2[j * matrix2ActualRows + k], 
										data2[(j + 1) * matrix2ActualRows + k], 
										data2[(j + 2) * matrix2ActualRows + k], 
										data2[(j + 3) * matrix2ActualRows + k]), 
									_sum);
							}
							_mm256_store_pd(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[k * matrix1ActualRows + i], 
									data1[(k + 1) * matrix1ActualRows + i], 
									data1[(k + 2) * matrix1ActualRows + i], 
									data1[(k + 3) * matrix1ActualRows + i]),
									_mm256_load_pd(&data2[j * matrix2ActualRows + k]),
									_sum);
							}
							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[j * matrix2ActualRows + k];
							}
							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualRows = matrix1.actualRows;
				size_t matrix2ActualCols = matrix2.actualCols;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[k * matrix1ActualRows + i]),
									_mm256_set1_pd(data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_pd(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[k * matrix1ActualRows + i],
									data1[(k + 1) * matrix1ActualRows + i],
									data1[(k + 2) * matrix1ActualRows + i],
									data1[(k + 3) * matrix1ActualRows + i]),
									_mm256_setr_pd(data2[k * matrix2ActualCols + j], 
										data2[(k + 1) * matrix2ActualCols + j], 
										data2[(k + 2) * matrix2ActualCols + j], 
										data2[(k + 3) * matrix2ActualCols + j]),
									_sum);
							}

							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (int k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[k * matrix2ActualCols + j];
							}

							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 4)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_set1_pd(data1[k * matrix1ActualRows + i]),
									_mm256_load_pd(&data2[k * matrix2ActualCols + j]),
									_sum);
							}
							_mm256_store_pd(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();
							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[k * matrix1ActualRows + i], 
									data1[(k + 1) * matrix1ActualRows + i], 
									data1[(k + 2) * matrix1ActualRows + i], 
									data1[(k + 3) * matrix1ActualRows + i]),
									_mm256_setr_pd(data2[k * matrix2ActualCols + j], 
										data2[(k + 1) * matrix2ActualCols + j], 
										data2[(k + 2) * matrix2ActualCols + j], 
										data2[(k + 3) * matrix2ActualCols + j]),
									_sum);
							}
							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[k * matrix2ActualCols + j];
							}

							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
		}
		else
		{
			if constexpr (matrix2Transposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;
				size_t matrix2ActualRows = matrix2.actualRows;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[i * matrix1ActualCols + k], 
									data1[(i + 1) * matrix1ActualCols + k], 
									data1[(i + 2) * matrix1ActualCols + k], 
									data1[(i + 3) * matrix1ActualCols + k]),
									_mm256_set1_pd(data2[j * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_pd(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1ActualCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[i * matrix1ActualCols + k]),
									_mm256_load_pd(&data2[j * matrix2ActualRows + k]), _sum);
							}
							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1ActualCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[j * matrix2ActualRows + k];
							}
							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 4)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_set1_pd(data1[i * matrix1ActualCols + k]),
									_mm256_setr_pd(data2[j * matrix2ActualRows + k], 
										data2[(j + 1) * matrix2ActualRows + k], 
										data2[(j + 2) * matrix2ActualRows + k], 
										data2[(j + 3) * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_pd(&dataResult[i * matrix1Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[i * matrix1ActualCols + k]),
									_mm256_load_pd(&data2[j * matrix2ActualRows + k]), _sum);
							}
							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[j * matrix2ActualRows + k];
							}
							dataResult[i * matrix1Cols + j] = sum;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = matrix1.actualCols;
				size_t matrix2ActualCols = matrix2.actualCols;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 4)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_setr_pd(data1[i * matrix1ActualCols + k],
									data1[(i + 1) * matrix1ActualCols + k],
									data1[(i + 2) * matrix1ActualCols + k],
									data1[(i + 3) * matrix1ActualCols + k]),
									_mm256_set1_pd(data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_pd(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[i * matrix1ActualCols + k]),
									_mm256_setr_pd(data2[k * matrix2ActualCols + j], 
										data2[(k + 1) * matrix2ActualCols + j], 
										data2[(k + 2) * matrix2ActualCols + j], 
										data2[(k + 3) * matrix2ActualCols + j]), 
									_sum);
							}
							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[k * matrix2ActualCols + j];
							}
							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 4)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();


							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_pd(_mm256_set1_pd(data1[i * matrix1ActualCols + k]),
									_mm256_load_pd(&data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_pd(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256d _sum = _mm256_setzero_pd();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 4)
							{
								_sum = _mm256_fmadd_pd(_mm256_load_pd(&data1[i * matrix1ActualCols + k]),
									_mm256_setr_pd(data2[k * matrix2ActualCols + j], 
										data2[(k + 1) * matrix2ActualCols + j], 
										data2[(k + 2) * matrix2ActualCols + j], 
										data2[(k + 3) * matrix2ActualCols + j]), _sum);
							}

							__m128d vlow = _mm256_castpd256_pd128(_sum);
							__m128d vhigh = _mm256_extractf128_pd(_sum, 1);
							vlow = _mm_add_pd(vlow, vhigh);

							__m128d high64 = _mm_unpackhi_pd(vlow, vlow);
							double sum = _mm_cvtsd_f64(_mm_add_sd(vlow, high64));

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[k * matrix2ActualCols + j];
							}

							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
		}
		return result;
	}

	inline float dot(vector<float>& vector1, vector<float>& vector2)
	{
#ifdef _DEBUG
		if (vector1._size != vector2._size) throw std::invalid_argument("The dimensions of both vectors must be the same");
#else
#endif
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		float* data1 = vector1._data;
		float* data2 = vector2._data;

		vector<float> result(size);

		float* dataResult = result._data;

		__m256 _dotProduct = _mm256_setzero_ps();

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_load_ps(&data1[i]);
			__m256 b = _mm256_load_ps(&data2[i]);

			_dotProduct = _mm256_fmadd_ps(a, b, _dotProduct);
		}

		__m256 _sum1 = _mm256_hadd_ps(_dotProduct, _dotProduct);
		__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

		__m128 lo128 = _mm256_castps256_ps128(_sum2);
		__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
		__m128 result128 = _mm_add_ps(lo128, hi128);
		float dotProduct = _mm_cvtss_f32(result128);

		for (size_t i = finalPos; i < size; i++)
		{
			dotProduct += data1[i] * data2[i];
		}

		return dotProduct;
	}
	
	template<bool returnTransposed = false, bool matrix1Transposed, bool matrix1Contiguous,
		bool matrix2Transposed, bool matrix2Contiguous>
	inline matrix<float> dot(matrix<float, matrix1Transposed, matrix1Contiguous>& matrix1, matrix<float, matrix2Transposed, matrix2Contiguous>& matrix2)
	{
#ifdef _DEBUG
		if (matrix1._cols != matrix2._rows) throw std::invalid_argument("Wrong dimensions");
#else
#endif

		size_t matrix1Rows = matrix1._rows;
		size_t matrix1Cols = matrix1._cols;

		size_t matrix2Rows = matrix2._rows;
		size_t matrix2Cols = matrix2._cols;

		float* data1 = matrix1._data;
		float* data2 = matrix1._data;

		matrix<float> result(matrix1Rows, matrix2Cols);

		float* dataResult = result._data;

		if constexpr (matrix1Transposed)
		{
			if constexpr (matrix2Transposed)
			{
				size_t matrix1ActualRows = matrix1.actualRows;
				size_t matrix2ActualRows = matrix2.actualRows;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 8)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[k * matrix1ActualRows + i]),
									_mm256_set1_ps(data2[j * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_ps(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_setr_ps(data1[k * matrix1ActualRows + i],
									data1[(k + 1) * matrix1ActualRows + i],
									data1[(k + 2) * matrix1ActualRows + i],
									data1[(k + 3) * matrix1ActualRows + i], 
									data1[(k + 4) * matrix1ActualRows + i],
									data1[(k + 5) * matrix1ActualRows + i],
									data1[(k + 6) * matrix1ActualRows + i],
									data1[(k + 7) * matrix1ActualRows + i]),
									_mm256_load_ps(&data2[j * matrix2ActualRows + k]),
									_sum);
							}

							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (int k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[j * matrix2ActualRows + k];
							}

							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 8)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_set1_ps(data1[k * matrix1ActualRows + i]),
									_mm256_setr_ps(data2[j * matrix2ActualRows + k],
										data2[(j + 1) * matrix2ActualRows + k],
										data2[(j + 2) * matrix2ActualRows + k],
										data2[(j + 3) * matrix2ActualRows + k], 
										data2[(j + 4) * matrix2ActualRows + k],
										data2[(j + 5) * matrix2ActualRows + k],
										data2[(j + 6) * matrix2ActualRows + k],
										data2[(j + 7) * matrix2ActualRows + k]),
									_sum);
							}
							_mm256_store_ps(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_setr_ps(data1[k * matrix1ActualRows + i],
									data1[(k + 1) * matrix1ActualRows + i],
									data1[(k + 2) * matrix1ActualRows + i],
									data1[(k + 3) * matrix1ActualRows + i], 
									data1[(k + 4) * matrix1ActualRows + i],
									data1[(k + 5) * matrix1ActualRows + i],
									data1[(k + 6) * matrix1ActualRows + i],
									data1[(k + 7) * matrix1ActualRows + i]),
									_mm256_load_ps(&data2[j * matrix2ActualRows + k]),
									_sum);
							}
							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[j * matrix2ActualRows + k];
							}
							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualRows = matrix1.actualRows;
				size_t matrix2ActualCols = matrix2.actualCols;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 8)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[k * matrix1ActualRows + i]),
									_mm256_set1_ps(data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_ps(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							float sum = 0.0f;
							for (int k = 0; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[k * matrix2ActualCols + j];
							}

							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 8)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_set1_ps(data1[k * matrix1ActualRows + i]),
									_mm256_load_ps(&data2[k * matrix2ActualCols + j]),
									_sum);
							}
							_mm256_store_ps(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							float sum = 0.0f;

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								sum += data1[k * matrix1ActualRows + i] * data2[k * matrix2ActualCols + j];
							}

							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
		}
		else
		{
			if constexpr (matrix2Transposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;
				size_t matrix2ActualRows = matrix2.actualRows;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 8)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_setr_ps(data1[i * matrix1ActualCols + k],
									data1[(i + 1) * matrix1ActualCols + k],
									data1[(i + 2) * matrix1ActualCols + k],
									data1[(i + 3) * matrix1ActualCols + k], 
									data1[(i + 4) * matrix1ActualCols + k],
									data1[(i + 5) * matrix1ActualCols + k],
									data1[(i + 6) * matrix1ActualCols + k],
									data1[(i + 7) * matrix1ActualCols + k]),
									_mm256_set1_ps(data2[j * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_ps(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1ActualCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[i * matrix1ActualCols + k]),
									_mm256_load_ps(&data2[j * matrix2ActualRows + k]), _sum);
							}
							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (size_t k = matrix1ActualCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[j * matrix2ActualRows + k];
							}
							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 8)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_set1_ps(data1[i * matrix1ActualCols + k]),
									_mm256_setr_ps(data2[j * matrix2ActualRows + k],
										data2[(j + 1) * matrix2ActualRows + k],
										data2[(j + 2) * matrix2ActualRows + k],
										data2[(j + 3) * matrix2ActualRows + k], 
										data2[(j + 4) * matrix2ActualRows + k],
										data2[(j + 5) * matrix2ActualRows + k],
										data2[(j + 6) * matrix2ActualRows + k],
										data2[(j + 7) * matrix2ActualRows + k]), _sum);
							}
							_mm256_store_ps(&dataResult[i * matrix1Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[i * matrix1ActualCols + k]),
									_mm256_load_ps(&data2[j * matrix2ActualRows + k]), _sum);
							}
							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[j * matrix2ActualRows + k];
							}
							dataResult[i * matrix1Cols + j] = sum;
						}
					}
				}
			}
			else
			{
				size_t matrix1ActualCols = matrix1.actualCols;
				size_t matrix2ActualCols = matrix2.actualCols;

				if constexpr (returnTransposed)
				{
					size_t matrix1FinalPosRows = matrix1.finalPosRows;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t i = 0; i < matrix1FinalPosRows; i += 8)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_setr_ps(data1[i * matrix1ActualCols + k],
									data1[(i + 1) * matrix1ActualCols + k],
									data1[(i + 2) * matrix1ActualCols + k],
									data1[(i + 3) * matrix1ActualCols + k], 
									data1[(i + 4) * matrix1ActualCols + k],
									data1[(i + 5) * matrix1ActualCols + k],
									data1[(i + 6) * matrix1ActualCols + k],
									data1[(i + 7) * matrix1ActualCols + k]),
									_mm256_set1_ps(data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_ps(&dataResult[j * matrix1Rows + i], _sum);
						}
					}
					for (size_t i = matrix1FinalPosRows; i < matrix1Rows; i++)
					{
						for (size_t j = 0; j < matrix2Cols; j++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[i * matrix1ActualCols + k]),
									_mm256_setr_ps(data2[k * matrix2ActualCols + j],
										data2[(k + 1) * matrix2ActualCols + j],
										data2[(k + 2) * matrix2ActualCols + j],
										data2[(k + 3) * matrix2ActualCols + j], 
										data2[(k + 4) * matrix2ActualCols + j],
										data2[(k + 5) * matrix2ActualCols + j],
										data2[(k + 6) * matrix2ActualCols + j],
										data2[(k + 7) * matrix2ActualCols + j]),
									_sum);
							}
							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[k * matrix2ActualCols + j];
							}
							dataResult[j * matrix1Rows + i] = sum;
						}
					}
				}
				else
				{
					size_t matrix2FinalPosCols = matrix2.finalPosCols;
					size_t matrix1FinalPosCols = matrix1.finalPosCols;

					for (size_t j = 0; j < matrix2FinalPosCols; j += 8)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();


							for (size_t k = 0; k < matrix1Cols; k++)
							{
								_sum = _mm256_fmadd_ps(_mm256_set1_ps(data1[i * matrix1ActualCols + k]),
									_mm256_load_ps(&data2[k * matrix2ActualCols + j]), _sum);
							}
							_mm256_store_ps(&dataResult[i * matrix2Cols + j], _sum);
						}
					}
					for (size_t j = matrix2FinalPosCols; j < matrix2Cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							__m256 _sum = _mm256_setzero_ps();

							for (size_t k = 0; k < matrix1FinalPosCols; k += 8)
							{
								_sum = _mm256_fmadd_ps(_mm256_load_ps(&data1[i * matrix1ActualCols + k]),
									_mm256_setr_ps(data2[k * matrix2ActualCols + j],
										data2[(k + 1) * matrix2ActualCols + j],
										data2[(k + 2) * matrix2ActualCols + j],
										data2[(k + 3) * matrix2ActualCols + j], 
										data2[(j + 4) * matrix2ActualCols + j],
										data2[(k + 5) * matrix2ActualCols + j],
										data2[(k + 6) * matrix2ActualCols + j],
										data2[(k + 7) * matrix2ActualCols + j]), _sum);
							}

							__m256 _sum1 = _mm256_hadd_ps(_sum, _sum);
							__m256 _sum2 = _mm256_hadd_ps(_sum1, _sum1);

							__m128 lo128 = _mm256_castps256_ps128(_sum2);
							__m128 hi128 = _mm256_extractf128_ps(_sum2, 1);
							__m128 result128 = _mm_add_ps(lo128, hi128);
							float sum = _mm_cvtss_f32(result128);

							for (size_t k = matrix1FinalPosCols; k < matrix1Cols; k++)
							{
								sum += data1[i * matrix1ActualCols + k] * data2[k * matrix2ActualCols + j];
							}

							dataResult[i * matrix2Cols + j] = sum;
						}
					}
				}
			}
		}
		return result;
	}
	
	// Concatenate

	template<typename T>
	inline vector<T> concatenate(vector<T>& vector1, vector<T>& vector2)
	{
		size_t vector1Size = vector1._size;
		size_t vector2Size = vector2._size;

		T* data1 = vector1._data;
		T* data2 = vector2._data;

		size_t size = vector1Size + vector2Size;

		vector<T> result(size);

		T* dataResult = result._data;

		for (size_t i = 0; i < vector1Size; i++)
		{
			dataResult[i] = data1[i];
		}
		for (size_t iResult{ vector1Size }, iVector2{ 0 }; iResult < size; iResult++, iVector2++)
		{
			dataResult[iResult] = data2[iVector2];
		}
		return result;
	}

	template<bool returnTransposed = false, typename T, bool matrix1Transposed, bool matrix1Contiguous,
		bool matrix2Transposed, bool matrix2Contiguous>
	inline matrix<T> concatenate_rowwise(matrix<T, matrix1Transposed, matrix1Contiguous>& matrix1, matrix<T, matrix2Transposed, matrix2Contiguous>& matrix2)
	{
#ifdef _DEBUG
		if (matrix1._cols != matrix2._cols) throw std::invalid_argument("Wrong dimensions");
#else
#endif

		size_t matrix1Cols = matrix1._cols;
		size_t matrix1Rows = matrix1._rows;

		size_t matrix2Cols = matrix2._cols;
		size_t matrix2Rows = matrix2._rows;

		T* data1 = matrix1._data;
		T* data2 = matrix2._data;

		size_t rows = matrix1Rows + matrix2Rows;
		size_t cols = matrix1Cols;

		matrix<T> result(rows, cols);

		double* dataResult = result._data;

		if constexpr (matrix1Transposed)
		{
			size_t matrix1ActualRows = matrix1.actualRows;
			if constexpr (matrix2Transposed)
			{
				size_t matrix2ActualRows = matrix2.actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t j = 0; j < cols; j++) 
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[j * rows + iResult] = data2[j * matrix2ActualRows + iMatrix2];
						}
					}
				}
				else
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[iResult * cols + j] = data2[j * matrix2ActualRows + iMatrix2];
						}
					}
				}
			}
			else
			{
				size_t matrix2ActualCols = matrix2.actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[j * rows + iResult] = data2[iMatrix2 * matrix2ActualCols + j];
						}
					}
				}
				else
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[iResult * cols + j] = data2[iMatrix2 * matrix2ActualCols + j];
						}
					}
				}
			}
		}
		else
		{
			size_t matrix1ActualCols = matrix1.actualCols;
			if constexpr (matrix2Transposed)
			{
				size_t matrix2ActualRows = matrix2.actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[j * rows + iResult] = data2[j * matrix2ActualRows + iMatrix2];
						}
					}
				}
				else
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[iResult * cols + j] = data2[j * matrix2ActualRows + iMatrix2];
						}
					}
				}
			}
			else
			{
				size_t matrix2ActualCols = matrix2.actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[j * rows + iResult] = data2[iMatrix2 * matrix2ActualCols + j];
						}
					}
				}
				else
				{
					for (size_t j = 0; j < cols; j++)
					{
						for (size_t i = 0; i < matrix1Rows; i++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j];
						}
						for (size_t iResult{ matrix1Rows }, iMatrix2{ 0 }; iResult < rows; iResult++, iMatrix2++)
						{
							dataResult[iResult * cols + j] = data2[iMatrix2 * matrix2ActualCols + j];
						}
					}
				}
			}
		}
		return result;
	}
	
	template<bool returnTransposed = false, typename T, bool matrix1Transposed, bool matrix1Contiguous,
		bool matrix2Transposed, bool matrix2Contiguous>
	inline matrix<T> concatenate_colwise(matrix<T, matrix1Transposed, matrix1Contiguous>& matrix1, matrix<T, matrix2Transposed, matrix2Contiguous>& matrix2)
	{
#ifdef _DEBUG
		if (matrix1._rows != matrix2._rows) throw std::invalid_argument("Wrong dimensions");
#else
#endif

		size_t matrix1Cols = matrix1._cols;
		size_t matrix1Rows = matrix1._rows;

		size_t matrix2Cols = matrix2._cols;
		size_t matrix2Rows = matrix2._rows;

		T* data1 = matrix1._data;
		T* data2 = matrix2._data;

		size_t rows = matrix1Rows;
		size_t cols = matrix1Cols + matrix2Cols;

		matrix<T> result(rows, cols);

		double* dataResult = result._data;

		if constexpr (matrix1Transposed)
		{
			size_t matrix1ActualRows = matrix1.actualRows;
			if constexpr (matrix2Transposed)
			{
				size_t matrix2ActualRows = matrix2.actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[jResult * rows + i] = data2[jMatrix2 * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[i * cols + jResult] = data2[jMatrix2 * matrix2ActualRows + i];
						}
					}
				}
			}
			else
			{
				size_t matrix2ActualCols = matrix2.actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[jResult * rows + i] = data2[i * matrix2ActualCols + jMatrix2];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[i * cols + j] = data1[j * matrix1ActualRows + i];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[i * cols + jResult] = data2[i * matrix2ActualCols + jMatrix2];
						}
					}
				}
			}
		}
		else
		{
			size_t matrix1ActualCols = matrix1.actualCols;
			if constexpr (matrix2Transposed)
			{
				size_t matrix2ActualRows = matrix2.actualRows;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[jResult * rows + i] = data2[jMatrix2 * matrix2ActualRows + i];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[i * cols + jResult] = data2[jMatrix2 * matrix2ActualRows + i];
						}
					}
				}
			}
			else
			{
				size_t matrix2ActualCols = matrix2.actualCols;
				if constexpr (returnTransposed)
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[j * rows + i] = data1[i * matrix1ActualCols + j];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[jResult * rows + i] = data2[i * matrix2ActualCols + jMatrix2];
						}
					}
				}
				else
				{
					for (size_t i = 0; i < rows; i++)
					{
						for (size_t j = 0; j < matrix1Cols; j++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j];
						}
						for (size_t jResult{ matrix1Cols }, jMatrix2{ 0 }; jResult < cols; jResult++, jMatrix2++)
						{
							dataResult[i * cols + jResult] = data2[i * matrix2ActualCols + jMatrix2];
						}
					}
				}
			}
		}
		return result;
	}
	
	// Cout

	std::ostream& operator<<(std::ostream& os, const vector<double>& vector)
	{
		for (size_t i = 0; i < vector._size; i++)
		{
			std::cout << vector._data[i] << std::endl;
		}
		return os;
	}

	std::ostream& operator<<(std::ostream& os, const vector<uint64_t>& vector)
	{
		for (size_t i = 0; i < vector._size; i++)
		{
			std::cout << vector._data[i] << std::endl;
		}
		return os;
	}

	std::ostream& operator<<(std::ostream& os, const vector<uint8_t>& vector)
	{
		for (size_t i = 0; i < vector._size; i++)
		{
			std::cout << (vector._data[i] ? 1 : 0) << std::endl;
		}
		return os;
	}

	std::ostream& operator<<(std::ostream& os, const vector<float>& vector)
	{
		for (size_t i = 0; i < vector._size; i++)
		{
			std::cout << vector._data[i] << std::endl;
		}
		return os;
	}

	std::ostream& operator<<(std::ostream& os, const vector<int>& vector)
	{
		for (size_t i = 0; i < vector._size; i++)
		{
			std::cout << vector._data[i] << std::endl;
		}
		return os;
	}

	template<bool otherTransposed, bool otherContiguous>
	std::ostream& operator<<(std::ostream& os, const matrix<double, otherTransposed, otherContiguous>& matrix)
	{
		size_t rows = matrix._rows;
		size_t cols = matrix._cols;

		double* data1 = matrix._data;

		if constexpr (otherTransposed)
		{
			size_t actualRows = matrix.actualRows;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << data1[j * actualRows + i] << " ";
				}
				std::cout << std::endl;
			}
		}
		else
		{
			size_t actualCols = matrix.actualCols;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << data1[i * actualCols + j] << " ";
				}
				std::cout << std::endl;
			}
		}
		return os;
	}

	template<bool otherTransposed, bool otherContiguous>
	std::ostream& operator<<(std::ostream& os, const matrix<float, otherTransposed, otherContiguous>& matrix)
	{
		size_t rows = matrix._rows;
		size_t cols = matrix._cols;

		float* data1 = matrix._data;

		if constexpr (otherTransposed)
		{
			size_t actualRows = matrix.actualRows;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << data1[j * actualRows + i] << " ";
				}
				std::cout << std::endl;
			}
		}
		else
		{
			size_t actualCols = matrix.actualCols;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << data1[i * actualCols + j] << " ";
				}
				std::cout << std::endl;
			}
		}
		return os;
	}

	template<bool otherTransposed, bool otherContiguous>
	std::ostream& operator<<(std::ostream& os, const matrix<uint8_t, otherTransposed, otherContiguous>& matrix)
	{
		size_t rows = matrix._rows;
		size_t cols = matrix._cols;

		uint8_t* data1 = matrix._data;

		if constexpr (otherTransposed)
		{
			size_t actualRows = matrix.actualRows;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << (data1[j * actualRows + i] ? 1 : 0) << " ";
				}
				std::cout << std::endl;
			}
		}
		else
		{
			size_t actualCols = matrix.actualCols;

			for (size_t i = 0; i < rows; i++)
			{
				for (size_t j = 0; j < cols; j++)
				{
					std::cout << (data1[i * actualCols + j] ? 1 : 0) << " ";
				}
				std::cout << std::endl;
			}
		}
		return os;
	}

	// num - object

	// +

	inline vector<double> operator+(double num, vector<double>& vector1)
	{
		return vector1 + num;
	}

	inline vector<float> operator+(float num, vector<float>& vector1)
	{
		return vector1 + num;
	}

	inline vector<uint64_t> operator+(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 + num;
	}

	inline vector<int> operator+(int num, vector<int>& vector1)
	{
		return vector1 + num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<double> operator+(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1.operator+<returnTransposed>(num);
	}
	
	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<float> operator+(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1.operator+<returnTransposed>(num);
	}

	// -

	inline vector<double> operator-(double num, vector<double>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		double* data1 = vector1._data;

		vector<double> result(size);

		double* dataResult = result._data;

		__m256d b = _mm256_set1_pd(num);

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_load_pd(&data1[i]);

			_mm256_store_pd(&dataResult[i], _mm256_sub_pd(b, a));
		}

		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num - data1[i];
		}
		return result;
	}

	inline vector<float> operator-(float num, vector<float>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		float* data1 = vector1._data;

		vector<float> result(size);

		float* dataResult = result._data;

		__m256 b = _mm256_set1_ps(num);

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_load_ps(&data1[i]);

			_mm256_store_ps(&dataResult[i], _mm256_sub_ps(b, a));
		}

		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num - data1[i];
		}
		return result;
	}

	inline vector<uint64_t> operator-(uint64_t num, vector<uint64_t>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint64_t* data1 = vector1._data;

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		__m256i b = _mm256_set1_epi64x(num);

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256i a = _mm256_loadu_epi64(&data1[i]);

			_mm256_storeu_epi64(&dataResult[i], _mm256_sub_epi64(b, a));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num - data1[i];
		}
		return result;
	}

	inline vector<int> operator-(int num, vector<int>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		int* data1 = vector1._data;

		vector<int> result(size);

		int* dataResult = result._data;

		__m256i b = _mm256_set1_epi32(num);

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256i a = _mm256_loadu_epi32(&data1[i]);

			_mm256_storeu_epi32(&dataResult[i], _mm256_div_epi32(b, a));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num / data1[i];
		}
		return result;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<double> operator-(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		double* data1 = matrix1._data;

		matrix<double> result(rows, cols);

		double* dataResult = result._data;

		__m256d b = _mm256_set1_pd(num);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_sub_pd(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = num - data1[i];
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(b, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d sub = _mm256_sub_pd(b, a);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = num - data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(b, a));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						__m256d sub = _mm256_sub_pd(b, a);

						__m128d val1 = _mm256_extractf128_pd(sub, 1);
						__m128d val2 = _mm256_castpd256_pd128(sub);

						_mm_store_sd(&dataResult[i * cols + j], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

						_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						dataResult[i * cols + j] = num - data1[j * matrix1ActualRows + i];
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_mm256_store_pd(&dataResult[j * rows + i], _mm256_sub_pd(b, a));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d sub = _mm256_sub_pd(b, a);

						__m128d val1 = _mm256_extractf128_pd(sub, 1);
						__m128d val2 = _mm256_castpd256_pd128(sub);

						_mm_store_sd(&dataResult[j * rows + i], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

						_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						dataResult[j * rows + i] = num - data1[i * matrix1ActualCols + j];
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_sub_pd(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = num - data1[i];
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_sub_pd(b, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d sub = _mm256_sub_pd(b, a);

							__m128d val1 = _mm256_extractf128_pd(sub, 1);
							__m128d val2 = _mm256_castpd256_pd128(sub);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = num - data1[i * matrix1ActualCols + j];
						}
					}
				}
			}
		}
		return result;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<float> operator-(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		float* data1 = matrix1._data;

		matrix<float> result(rows, cols);

		float* dataResult = result._data;

		__m256 b = _mm256_set1_ps(num);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_sub_ps(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] - num;
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(b, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] - num;
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]);

						_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(b, a));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] - num;
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]);

						_mm256_store_ps(&dataResult[j * rows + i], _mm256_sub_ps(b, a));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] - num;
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_sub_ps(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] - num;
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_sub_ps(b, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] - num;
						}
					}
				}
			}
		}
		return result;
	}

	// *

	inline vector<double> operator*(double num, vector<double>& vector1)
	{
		return vector1 * num;
	}

	inline vector<float> operator*(float num, vector<float>& vector1)
	{
		return vector1 * num;
	}

	inline vector<uint64_t> operator*(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 * num;
	}

	inline vector<int> operator*(int num, vector<int>& vector1)
	{
		return vector1 * num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<double> operator*(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 * num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<float> operator*(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 * num;
	}

	// /

	inline vector<double> operator/(double num, vector<double>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		double* data1 = vector1._data;

		vector<double> result(size);

		double* dataResult = result._data;

		__m256d b = _mm256_set1_pd(num);

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256d a = _mm256_load_pd(&data1[i]);

			_mm256_store_pd(&dataResult[i], _mm256_div_pd(b, a));
		}

		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num / data1[i];
		}
		return result;
	}

	inline vector<float> operator/(float num, vector<float>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		float* data1 = vector1._data;

		vector<float> result(size);

		float* dataResult = result._data;

		__m256 b = _mm256_set1_ps(num);

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256 a = _mm256_load_ps(&data1[i]);

			_mm256_store_ps(&dataResult[i], _mm256_div_ps(b, a));
		}

		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num / data1[i];
		}
		return result;
	}

	inline vector<uint64_t> operator/(uint64_t num, vector<uint64_t>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		uint64_t* data1 = vector1._data;

		vector<uint64_t> result(size);

		uint64_t* dataResult = result._data;

		__m256i b = _mm256_set1_epi64x(num);

		for (size_t i = 0; i < finalPos; i += 4)
		{
			__m256i a = _mm256_loadu_epi64(&data1[i]);

			_mm256_storeu_epi64(&dataResult[i], _mm256_div_epi64(b, a));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num / data1[i];
		}
		return result;
	}

	inline vector<int> operator/(int num, vector<int>& vector1)
	{
		size_t size = vector1._size;

		size_t finalPos = vector1.finalPos;

		int* data1 = vector1._data;

		vector<int> result(size);

		int* dataResult = result._data;

		__m256i b = _mm256_set1_epi32(num);

		for (size_t i = 0; i < finalPos; i += 8)
		{
			__m256i a = _mm256_loadu_epi32(&data1[i]);

			_mm256_storeu_epi32(&dataResult[i], _mm256_div_epi32(b, a));
		}
		for (size_t i = finalPos; i < size; i++)
		{
			dataResult[i] = num / data1[i];
		}
		return result;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<double> operator/(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		double* data1 = matrix1._data;

		matrix<double> result(rows, cols);

		double* dataResult = result._data;

		__m256d b = _mm256_set1_pd(num);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_div_pd(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = num / data1[i];
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

							_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(b, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < finalPosCols; j += 4)
						{
							__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
								data1[(j + 1) * matrix1ActualRows + i],
								data1[(j + 2) * matrix1ActualRows + i],
								data1[(j + 3) * matrix1ActualRows + i]);

							__m256d div = _mm256_div_pd(b, a);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&dataResult[j * rows + i], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

							_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
						}
						for (size_t j = finalPosCols; j < cols; j++)
						{
							dataResult[j * rows + i] = num / data1[j * matrix1ActualRows + i];
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 4)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256d a = _mm256_setr_pd(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i]);

						_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(b, a));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < finalPosRows; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[j * matrix1ActualRows + i]);

						__m256d div = _mm256_div_pd(b, a);

						__m128d val1 = _mm256_extractf128_pd(div, 1);
						__m128d val2 = _mm256_castpd256_pd128(div);

						_mm_store_sd(&dataResult[i * cols + j], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

						_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						dataResult[i * cols + j] = num / data1[j * matrix1ActualRows + i];
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 4)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j]);

						_mm256_store_pd(&dataResult[j * rows + i], _mm256_div_pd(b, a));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

						__m256d div = _mm256_div_pd(b, a);

						__m128d val1 = _mm256_extractf128_pd(div, 1);
						__m128d val2 = _mm256_castpd256_pd128(div);

						_mm_store_sd(&dataResult[j * rows + i], val2);
						val2 = _mm_shuffle_pd(val2, val2, 1);
						_mm_store_sd(&dataResult[(j + 1) * rows + i], val2);

						_mm_store_sd(&dataResult[(j + 2) * rows + i], val1);
						val1 = _mm_shuffle_pd(val1, val1, 1);
						_mm_store_sd(&dataResult[(j + 3) * rows + i], val1);
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						dataResult[j * rows + i] = num / data1[i * matrix1ActualCols + j];
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 4)
					{
						__m256d a = _mm256_load_pd(&data1[i]);

						_mm256_store_pd(&dataResult[i], _mm256_div_pd(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = num / data1[i];
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 4)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256d a = _mm256_load_pd(&data1[i * matrix1ActualCols + j]);

							_mm256_store_pd(&dataResult[i * cols + j], _mm256_div_pd(b, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < finalPosRows; i += 4)
						{
							__m256d a = _mm256_setr_pd(data1[i * matrix1ActualCols + j],
								data1[(i + 1) * matrix1ActualCols + j],
								data1[(i + 2) * matrix1ActualCols + j],
								data1[(i + 3) * matrix1ActualCols + j]);

							__m256d div = _mm256_div_pd(b, a);

							__m128d val1 = _mm256_extractf128_pd(div, 1);
							__m128d val2 = _mm256_castpd256_pd128(div);

							_mm_store_sd(&dataResult[i * cols + j], val2);
							val2 = _mm_shuffle_pd(val2, val2, 1);
							_mm_store_sd(&dataResult[(i + 1) * cols + j], val2);

							_mm_store_sd(&dataResult[(i + 2) * cols + j], val1);
							val1 = _mm_shuffle_pd(val1, val1, 1);
							_mm_store_sd(&dataResult[(i + 3) * cols + j], val1);
						}
						for (size_t i = finalPosRows; i < rows; i++)
						{
							dataResult[i * cols + j] = num / data1[i * matrix1ActualCols + j];
						}
					}
				}
			}
		}
		return result;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<float> operator/(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		size_t rows = matrix1._rows;
		size_t cols = matrix1._cols;

		float* data1 = matrix1._data;

		matrix<float> result(rows, cols);

		float* dataResult = result._data;

		__m256 b = _mm256_set1_ps(num);

		if constexpr (thisTransposed)
		{
			if constexpr (returnTransposed)
			{
				if constexpr (thisContiguous)
				{
					size_t size = matrix1._size;

					size_t finalPosSize = matrix1.finalPosSize;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_div_ps(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] / num;
					}
				}
				else
				{
					size_t finalPosRows = matrix1.finalPosRows;
					size_t finalPosCols = matrix1.finalPosCols;

					size_t matrix1ActualRows = matrix1.actualRows;

					for (size_t i = 0; i < finalPosRows; i += 8)
					{
						for (size_t j = 0; j < cols; j++)
						{
							__m256 a = _mm256_load_ps(&data1[j * matrix1ActualRows + i]);

							_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(b, a));
						}
					}
					for (size_t i = finalPosRows; i < rows; i++)
					{
						for (size_t j = 0; j < cols; j++)
						{
							dataResult[j * rows + i] = data1[j * matrix1ActualRows + i] / num;
						}
					}
				}
			}
			else
			{
				size_t finalPosCols = matrix1.finalPosCols;
				size_t finalPosRows = matrix1.finalPosRows;

				size_t matrix1ActualRows = matrix1.actualRows;

				for (size_t j = 0; j < finalPosCols; j += 8)
				{
					for (size_t i = 0; i < rows; i++)
					{
						__m256 a = _mm256_setr_ps(data1[j * matrix1ActualRows + i],
							data1[(j + 1) * matrix1ActualRows + i],
							data1[(j + 2) * matrix1ActualRows + i],
							data1[(j + 3) * matrix1ActualRows + i],
							data1[(j + 4) * matrix1ActualRows + i],
							data1[(j + 5) * matrix1ActualRows + i],
							data1[(j + 6) * matrix1ActualRows + i],
							data1[(j + 7) * matrix1ActualRows + i]);

						_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(b, a));
					}
				}
				for (size_t j = finalPosCols; j < cols; j++)
				{
					for (size_t i = 0; i < rows; i++)
					{
						dataResult[i * cols + j] = data1[j * matrix1ActualRows + i] / num;
					}
				}
			}
		}
		else
		{
			if constexpr (returnTransposed)
			{
				size_t matrix1ActualCols = matrix1.actualCols;

				size_t finalPosRows = matrix1.finalPosRows;
				size_t finalPosCols = matrix1.finalPosCols;

				for (size_t i = 0; i < finalPosRows; i += 8)
				{
					for (size_t j = 0; j < cols; j++)
					{
						__m256 a = _mm256_setr_ps(data1[i * matrix1ActualCols + j],
							data1[(i + 1) * matrix1ActualCols + j],
							data1[(i + 2) * matrix1ActualCols + j],
							data1[(i + 3) * matrix1ActualCols + j],
							data1[(i + 4) * matrix1ActualCols + j],
							data1[(i + 5) * matrix1ActualCols + j],
							data1[(i + 6) * matrix1ActualCols + j],
							data1[(i + 7) * matrix1ActualCols + j]);

						_mm256_store_ps(&dataResult[j * rows + i], _mm256_div_ps(b, a));
					}
				}
				for (size_t i = finalPosRows; i < rows; i++)
				{
					for (size_t j = 0; j < cols; j++)
					{
						dataResult[j * rows + i] = data1[i * matrix1ActualCols + j] / num;
					}
				}
			}
			else
			{
				if constexpr (thisContiguous)
				{
					size_t finalPosSize = matrix1.finalPosSize;
					size_t size = matrix1._size;

					for (size_t i = 0; i < finalPosSize; i += 8)
					{
						__m256 a = _mm256_load_ps(&data1[i]);

						_mm256_store_ps(&dataResult[i], _mm256_div_ps(b, a));
					}
					for (size_t i = finalPosSize; i < size; i++)
					{
						dataResult[i] = data1[i] / num;
					}
				}
				else
				{
					size_t matrix1ActualCols = matrix1.actualCols;

					size_t finalPosCols = matrix1.finalPosCols;
					size_t finalPosRows = matrix1.finalPosRows;

					for (size_t j = 0; j < finalPosCols; j += 8)
					{
						for (size_t i = 0; i < rows; i++)
						{
							__m256 a = _mm256_load_ps(&data1[i * matrix1ActualCols + j]);

							_mm256_store_ps(&dataResult[i * cols + j], _mm256_div_ps(b, a));
						}
					}
					for (size_t j = finalPosCols; j < cols; j++)
					{
						for (size_t i = 0; i < rows; i++)
						{
							dataResult[i * cols + j] = data1[i * matrix1ActualCols + j] / num;
						}
					}
				}
			}
		}
		return result;
	}

	// ==

	inline vector<uint8_t> operator==(double num, vector<double>& vector1)
	{
		return vector1 == num;
	}

	inline vector<uint8_t> operator==(float num, vector<float>& vector1)
	{
		return vector1 == num;
	}

	inline vector<uint8_t> operator==(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 == num;
	}

	inline vector<uint8_t> operator==(int num, vector<int>& vector1)
	{
		return vector1 == num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator==(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 == num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator==(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 == num;
	}

	// != 

	inline vector<uint8_t> operator!=(double num, vector<double>& vector1)
	{
		return vector1 != num;
	}

	inline vector<uint8_t> operator!=(float num, vector<float>& vector1)
	{
		return vector1 != num;
	}

	inline vector<uint8_t> operator!=(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 != num;
	}

	inline vector<uint8_t> operator!=(int num, vector<int>& vector1)
	{
		return vector1 != num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator!=(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 != num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator!=(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 != num;
	}

	// >

	inline vector<uint8_t> operator>(double num, vector<double>& vector1)
	{
		return vector1 < num;
	}

	inline vector<uint8_t> operator>(float num, vector<float>& vector1)
	{
		return vector1 < num;
	}

	inline vector<uint8_t> operator>(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 < num;
	}

	inline vector<uint8_t> operator>(int num, vector<int>& vector1)
	{
		return vector1 < num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator>(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 < num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator>(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 < num;
	}

	// >=

	inline vector<uint8_t> operator>=(double num, vector<double>& vector1)
	{
		return vector1 <= num;
	}

	inline vector<uint8_t> operator>=(float num, vector<float>& vector1)
	{
		return vector1 <= num;
	}

	inline vector<uint8_t> operator>=(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 <= num;
	}

	inline vector<uint8_t> operator>=(int num, vector<int>& vector1)
	{
		return vector1 <= num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator>=(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 <= num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator>=(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 <= num;
	}

	// <

	inline vector<uint8_t> operator<(double num, vector<double>& vector1)
	{
		return vector1 > num;
	}

	inline vector<uint8_t> operator<(float num, vector<float>& vector1)
	{
		return vector1 > num;
	}

	inline vector<uint8_t> operator<(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 > num;
	}

	inline vector<uint8_t> operator<(int num, vector<int>& vector1)
	{
		return vector1 > num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator<(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 > num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator<(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 > num;
	}

	// <= 

	inline vector<uint8_t> operator<=(double num, vector<double>& vector1)
	{
		return vector1 >= num;
	}

	inline vector<uint8_t> operator<=(float num, vector<float>& vector1)
	{
		return vector1 >= num;
	}

	inline vector<uint8_t> operator<=(uint64_t num, vector<uint64_t>& vector1)
	{
		return vector1 >= num;
	}

	inline vector<uint8_t> operator<=(int num, vector<int>& vector1)
	{
		return vector1 >= num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator<=(double num, matrix<double, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 >= num;
	}

	template<bool returnTransposed = false, bool thisTransposed, bool thisContiguous>
	inline matrix<uint8_t> operator<=(float num, matrix<float, thisTransposed, thisContiguous>& matrix1)
	{
		return matrix1 >= num;
	}

	//---------------------------------------------------------------------------

}
